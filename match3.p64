picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA2LTE4IDEyOjEzOjQ0Iixtb2RpZmllZD0iMjAyNS0w
Ny0wMSAyMDo1MDo1OSIscmV2aXNpb249MjA5N11dbHo0AB0aAADKUgAA8yF7WzBdPXtibXA9cHh1
AEMgEBAE8FYHEAfAF9AXwAcQB-BWLGZsYWdzPTAscGFuX3gIAMp5PTAsem9vbT0xfSw_AP8vgB8Y
wB7ALrBOoE6ADhBOYC4QDgguUC4QDhguMC4gDiguIC4AHjguEF5ILhAueC4gHngeMC5YHlAuOB6A
XkBtABzzEfAGLxuwDiAOkA4QCwAegC4QHsAesE6QbnCOUB4QHhAeBgD-A55QPgBOUC4gLnBugA4A
DgAeUGgAHPQVYE8QkG5wLiEuUC5BLjAuUS4wHhEOEQ4RHiAuAR4RHhEOEC4RCAD-CQ4xDhFekU6h
TpFucS4QPlEuQC4xLmB_MHMAHPMLUE8egI5QrkAuDxIuDS4wLi0OLS4gHj0OPR4GAP8OLh0uHS4g
zjCuQK5APi0_UC4tLmAuLS5wLg0uoC7hAB3-KfANDxmwPqAeIA5AfgAOUD4aPlA_Gi5gXhAOQB4a
blAOGl5gDhouGi5AHhAeGh5gTgoOkF6QTvAGZwAdtQVagHpgmkC6INoQAgCvILpAmmB6gFrwBU4A
HrVfF4B_YJ5AviDeEAIAjyC_QJ5gfoBeTwAeX-8PAdAeAgAGL-4BTwAccGAPGAAOwC4LA_BwHgAe
CB5gLhAeCB5QPhEDQUAOCB4TAz0OCA4VAy8eMBUDK-sGBT8boA4wDoAOQB5wDgAOCxAegA4gGAMg
AwADAAQaAy8DEBsDUk8MDhEMHQNUaA8ODS4MDSADnx5NHmAuDQ8WDSMDJPAYoA8Z0B7AHtAegH4Q
DkCuMF4aHlAOKh4aAA5AHipeMC4aLgoeYE4qIwOfKk5AHgA_IA5QJAO_T-cB0BcCAAYf9yMDIOCw
DhAugB4QLnAeEE5QPicDQFAeCA4pA0BADhgeKwMnME48BjEOCA4pA28eCC5IHiArAzwwQB5gCAAj
CyAqAwMkA0EeEx4TKgNvA05QLhMAKgNKAiIDAAoAPxwRHCoDTa8PDi0ODC0eIC4MLAMBbx4dDxYd
HiwDKCDQDiwD-xMALjCuQA4qTlAeKg4aHkBuGh5QbgoOYC4aXkAeKm5AHhAuKANzH-AxAE2AIB8Y
EA6gHhCnCATvAoFOQE4QTjAeCCUJMSAOGCcJMBAOKBQGEB4IAN8AHjgeEB4oHkgeIB6I7QI4UWAO
UB5QBABRQE5ACzDvAgHnAjAeCwMDAATvAi8LE_8CVG8PHAwRDQzyAk1sHw4dDhwd8gIyLk0u8gJf
DS8WDR5BCSkjsA5BCSAuGvEC8AA_YI5ArlAeCi4aDmAeGh4-CZ8aHgouYB4APpDzAtHwCKAPGNAe
8A4O0B7QLrBOUA4wXjAeMB4Y7gjQPhguEH4oLhAuCC4YD-0Crx4oLRgeMC4IPQjfAiXQAw8bEC6A
DlAOYA5gHqsHMGAOMN0C0B4TLjALID4TDgMOUDPkAkAOAysO5AKPPisuUB4DKz7nAkVAHA4RHN0C
kAwPHBwBDA0cAQwAMB0MAQQAb14BHCEcEe0CNOEeHw5uQE0OLR4wDp0eIAQA8AsNHxcNDxINHxcd
HiAOHQwNHg0MHR4gHi0eLZAF-wWODQ5AHn0OUA5tDmAOHSwdDnAOXfQCJSCAKvUCMC46DvcC8A0K
FwouUDoXCh5QOg4qAA5ADhoHCl5QChcKDjpgBgBgChcKHkA6BwCfDmA_ChcKgC4qCAMhH-AxAH7w
ErAfGDAOcB5ADnAe8C8OwD4wDkBuEB4ADgCOEA4wLghOUOcC3z4gPhgdGB4wHigdDxfoAiXwEhAP
GzAecA5gDvACDiAOoA7wCx6wPhMQDlAeMw4gDjAOS_gC8QsTCy8aGx4wDQAOAwsNAB0LHiANEA4D
Cy0LAwoA-wITKw4TDlAOEwsjDhNgAz4DDvwCNf8gDh8cAQ4BHREeIA49DgEdDBEOEB4NAB0MAT0B
DhAeHQAdAQ0QHV49AU1OER0hLQH_Aj3yAC8XHTwNHiAODBAMDRwQDAoAUA8SDRAcEwNELB4sDQQD
-w4uDW5ADp1ALVwdMB0sIBwdMB0cQAwdQD1MDXB9IAgDJ-80MDoXKgAOUCoHEAcKHlAqIAcKDlAK
Bxo3GkAOJ2pwFwonCmAHAAcKByAHHkAnChcQBwpQCgcKDgo3ClBaFxpwasAaQNsCHg8xAH_wCx8Y
0B7gDvAgDvDfDkDwAQ5QgQ7-AV5gPj8OHlAeHS8XPlAuHB39AiDwDg8bYB4wDgAO8DceQA5QDisf
GoANGy0OMA4gDj0A_QL-IwMdIA0rUAsNIB0LHlALHQANACsOUF0AEw4wDgANEw0DHRsDIA4gAw4N
HgsOQA4gDgAN9wIt0C8cMS0eID0BDgENEA1eA8QdDgENIA0OEA0wDQwKAP8NPSAdHh0gHQENMA0u
HQBNMA0uPREtIA0_LSFNDgADKvAAIA4gPg8XXg0OAD4tLj0Q0ABwDQBNAA0OIAMAkkAdDhAdIB0w
LQYA-yRQHRANEA8ODQ4wDRB9HhC9AA4QvSAtAD0gDQwdAC1gPRBNUB0ADgA9ED0AHQAOQAx9AA4L
AylCBwAXCg0D-yAXHlAXMBcOUCcwBxpADocKcBcQB3AHEBcwBx4wBxAHQAcKQDdQClAqAEcKcBon
GgYDskAgDxhw_ggAqgX-AUoO8CkOwA8XLqBdkA0IDi30BSH-GR8a8AAPG3APGoAeEA8boA3wBQ7w
BAsgDhAN8AANoAPwBQ7QDuAO8C_EDx7yCBAvHKAfEBAOAA5wHlAOkAFADuAPHOANAgASDgcA-wYQ
Dg2QDhAucA0OMB0eASAOHWAuTTDFAB4hFyCxAtAPFy4NDl0OAA4dDi0OpwIgEA6pA-AWHVAdAA0O
oA1gDWANEA1ADVANwA8OAA0wDXAtDhANgB0ADhANkN8C-woNoAxNoA0APXANEA4APZAOAB0QDA0Q
TQANkQAc-zLgDxnADnAnACcOMBcAFxoAFxAOMAcAGgdADoAHEAcAFwAO8AMH0A7wDwdwFw4wB3An
MCdgCgdABxpABwoHQBcaIKkCf-CAICAE-yABBP4OBP4OFD4Efh8V7gQ_BG497gQuFE4NDxQ97hQO
FAkELh0MPf4ADBQKGQQODQQNHC3_ABwUGg0kHAQt-gAsFBoZLAQt3gouHBQaCQwkLb4KFBoJLBQa
JD2eCg4EGgQJHC8ZBAoNFE0FngQKKQQcCggPGA8ZDxgEbRU_Gg4EDhoJBB8ZDAoPHwoYAPByCH0O
FU4JBAopCxoECg8fCQocXT4lLgw6CwosBAosXV4lDhwpDAQMVBxNfg0lLBlkKU0uDT4JDCU8CTQp
BAk9fgQJHCU8CSQ5BD1uDQkKBBwFHSwEGSQMBF1OGQokCS0MGQQaJBwETQ4dHhokCR0ODQwKBAlE
HAQtDh0_NAkKHQ4NRwD-YwQMBAk9Hi00DQoNHg0EGQQqBCkECZ0EGQQdDh0aBBkECgQJDSmdBCkE
PXQJHQkVjQQpCj0UGTQJLRUJXRIEOSIdJBkUCT0FOS0SBDkyDTQKFBkCHRUpLRIEDRkqIiQaJAky
BQ0JPRIUKRpCFBoUGSIVTbYBCxw0tgGxnyAvFP8gDR8UCg8KABEJCgChHxQK-yAIGR8VCQoA8QAH
ChkUCf4KChkk-gkEKRQFAPAtnhkEGZ4EGSSOCVQJfgQpDgR_GSQfFCR_BCmOClQtFG4EGQSOCQQZ
NC0UXhQJBI4EKUQdFF4UGQp_CklkCAD-co4ZGilEXhQpCk4KCQ4ECRo5FA0ETh8YJAkEGh4KCQ8V
BAkaSRQNBD4PGB4kKQQeCQR5VG5EmZRuhBkECbRuDCQthD00bgweNC1UPSQODK40PTQdJAweDJ4c
DsQeHP4AHEQvFQw_DL4yOwwrIt5SSwwrQr5ia3Kucjti7rL_BTL_JCkBHPkb8Hb4BfC5WEA4MCiA
GIAYEBggCAAYYBiAGEAIEAgQCGAIkAhQCBAIIAhQCgAiQBgKAHEwKCAIQAggDABhUBgQCDAYDAAR
GCAA-wkYMAggCGBoIEhACAAo8AIYYCjwuvgI8FSjAB75GfMF8LlTQDMwI4ATgBMQEyADABNgE4AT
QAMQAxADYAOQA1ADEAMgA1AKACJAEwoAcTAjIANAAyAMAGFQExADMBMMABETIAD-BhMwAyADYGMg
Q0ADACPwAhNgI-C686MAIfka-xAF8LleQD4wLoAegB4QHiAOAB5gHoAeQA4QDhAOYA6QDlAOEA4g
DlAKACJAHgoAAI8VAD8JAAwAYVAeEA4wHgwAER4gABAejwn-AWBuIE5ADgAu8AIeYC7wuv6kACIf
HqQAj-kZ_gXwuVpAOjAqgBqAGhAaIAoAGmAagBpAChAKEApgCpAKUAoQCiAKUAoAIkAaCgBxMCog
CkAKIAwAYVAaEAowGgwAERogAP8GGjAKIApgaiBKQAoAKvACGmAq8Lr6owAPD0EGHQ3UAPBEPxMx
vi0ODR4tHxAOAS5xbh0eLQ4dHBEuAQ4YHihuDQ8OfQwOIR4IHxgYHggOSC0PDg5NHA4xPg8YCB4I
Lw4oOw0OCz0MYS4oDxgIOygrHQs9AS4SEfItCBqoOx0MDREOMTgKKDoIKhgbPQwPFUEIHwkIChgq
OAofDAwYGy0MLxURGA8JGCofFRooCgwfDCgbHQwfFADxAQoPFQopOhgKGAIIAigdGQEUAPNsCQo5
ChlKGBIoHSkYBwgKWQoZCgkfDwkqGAIYHBkYBwgaSQoZCjkKCQYAOhgMGQgHCDoSBgkKWRoPFgYS
FgIaDAknCCoSBgUZCkkKDgYOCQUGDAUWDAgSBwgKEhoCBQIKmQ4GHAYMBgwHIgcKIgoSBQYKCDkO
CQ4JHgwFFwCAEgoCGgIGBRIYAHAuDAY8BxIHEgDACiIFBgIKCBkBCU5MEwAQCD8A8DsWEgpIOw48
ChIaCAoSCiIaBgI6WAssDiIKAggiChIKAgoCBgUGEUoYCxwOMgoIYgoCCggKAQ5BDgoICw4MDiIa
YhoCCgIKUQ4RGA8AMAoIEjUAEAg4APABEQlRDgoIDgwOChIKCDIaCCkAwClRHgguAgoSCjIICnAA
BBEA8BICCjIaAhoCKgkBCTEIAQ4IPgpiCkIKCBoZARkRGAEeAQ4iACIKEqYAUClBDiEONAAgAjrW
AF8CGhI5cRcMDBw1UwLwOA8gBR4fGQ4d-gwtCS4JngWOBT4JChkNPgmeBa4JGhkNbg3OBQ4FLgkq
CR0eCv4BBQ4JHikaCR3_ChkaKU4N-gQZOgn_Bg0uBwDgAAWOCUr_BA1eCSofFA4QAPAKTg0OCRoc
Cu4FXg0eCRo87gUeBU4NCQoNDAIAkP4EFR4JDRwPGAwA8EEICUwS3gV_CQ0eCgsCHO4FLgUuDQwe
Cg0MAhz_BgwuCiwOCQyuBY4MDQ4JDSweDRz_AxwOCSwPFQweDA2OBY4NHgkMDSj_AA0eBU4JDQge
GFIA8AAIPhg_Bf4CCQhOGP4GCQ0HAP8sAgkeHQheCQwuBf4BDQhuCQzeIgkSDQRSDQ4crlINCQ0E
KQ0ZIhzyAB0JDQQKDAkdOSxZDWItWU1pTRJYARzwKkIDEgMiCUIJDxTyATMyCTIJUg8ZIg5yIx8T
EgkyGTIOAikEciMdAgpSCgkyGRoJBHITHQlyCjIJKgsA8QQNGSIKAgoSDgIOAlkEcg0DDQkKTwKw
HhIaGQIJgh0TBxn3AfAZCQIOChIqBwliTSMKHgoZBB4iKgkHCVJdIxoOCgQPFAQyEwoJGmJtIwYK
8OgJEx0CAxIZCjINEk0EQw8UDxUJEx4TEg4JDiITLRMNBDMvFB8VLiMSLiIPEQMtIwQTTxQJPxUJ
GgIuMg8RMwkTFAoOPxQZPxUpLCINHxEDCwkjBA4KDhofFAkMCQ1cEk0bCSM6BBoWCRzdGwQJKgke
HRoGDAkMTUM9CVoeLQcKBhwJLZMNChcqHgMtBwo8HYMtChcaCRszGhEcgy0PEA0JKg5LEwoPBREV
Uw0PEAMtAB0pDVsKBg4RLEMNEC0AXVsWBB4sQw1QfSsKFg4EDAQcMx1QjRsKBgQeBDwTLVARbRsK
BgwGHgQsExANUDFtCgkGBAYOBh4MDwAiQV0PALEEBh4JA3BxPQoJFg4A-wcOCSAEIMEaCRQcNAkE
EQTROmwUDCRh6AEMD8QFHg8xAP------------fwK2QQBPD-I1tAKxBbIDuAK0ArIDsAG0A7MDtA
W9ALMBswCzALIAsQGyALgAtgC0AbIBtQC1AbYAsgC9AOAGQLMAtQCzAcAOErQAtQCwALUAvwAgtQ
Cx0AIhvAGwCDCwALQAtACxAdAKQbEAswCxALMDuQHwAgGzAfABAbIwAS4CAAMztgG1gAAYAAdTAb
IAtAO_A8AAYeABEgEgAjMAs8AAF5ABKglAAAGABgGwALMGswdwAhQBuUADQLIBsdAGFAKyAbQAsd
AAXsAAEfAAApACAgG8EAESAEADQgC8AkAfsAW0ArQCtAGxArMDsAW-C-bQE2Ny42AQATN3oBTzYu
NzV9AQHzFyAgBLA-IDbwBW5m8ACOhsCelqCupoC_tmDOxkDe1jDe1iDe9gAQBABPAO72AQMAAhQA
JQAx7uYgNgD-CUDOxmC_toCupqCelsCOhvAAflbwBU4msEkCHPAPEA8SDyAvEh8gLxIPIA8SIA4C
DyAeDRINHg0CDhAOBwBjHx4CDR4NDQATHAwAJAINJQDwAQAuDS4dLg0u-QEuDVINLg0aACECPAYA
QQ4NHgIzACACHgoABD8AMQIOABoAEBIYAPIODiA_DRINPkAODQ4CHQIODQ5QDgINDh0ODQIOYA4u
AA9LGgweNhwDDzEA3RCA4AMTgLwC_QGgG0AbYDtAW0CLACsgO-AR4QNxkBtAG3AbYPcCIhAbCQNH
IAvwEOgDASMAAeIDQjALYBtqAyXwEOwDltAbMAsAC2ALECEANxvwFO4DUqALAAsgIwBQG0ALIBsj
ABAwiAAF8QNhGwALEAsQcwOpQEtwG1ALYBvwEPQDAEAAAmEAADAEBiMABfcDcyAbIBtAazBfABhw
wgAA_QMRMBQEAhoEEVDEABAgQAAK-wMBJQAChgAVCyUAFA8CBDErYCv_A1ArMCsgOwQAO-D-ApQB
QzM0LjWXAS8tMpgBAQD7A-EQfyDwBd7wAP4CwP4EoP4GgP4IYP4KQP4MMP4MIP4OEAMARAD_8AAM
ABEgGwD-BkD_CmD_CID_BqD_BMD_AvAA3vAFftwDHS-w8DEA-w8BOgMXejoDcDBbEFtwSxAiBwAW
AD0r8AFAAzFACyAsAgBYBgJ3AgVgBgR9BhMwKQASYIICFAueAgMnAApMAwQnABuAJQANUgMA-AYC
sgYakHcADFoDUkA7MEtAJQAqS1BOAAZeAwJOACMQGykASAsQG1CeAARmAyEwCy4EIRuAmAAN6gAF
bgMAxQAiGyDsACMLMDUBL-ACdAMCAEABUUALMCsgxQAC8gBIMAvwAXwDcFsQKzArMEuIBzAwKwCK
ARv32QFdLTcuMTaHBzk0LjGdBwH1AR0ylwPzEzY-IPAFZm7wAIaOwJaeoKaugLa_YMbOQNbeMNbe
IPYA3hAEABQAggcMAwAUACUAMebuIDYA-whAxs5gtr6Apq6glp7Aho7wAFZ_8AUmTrYD-0YVjy4C
MUA7QKoFSyA78CTPCjFQO1DiBQHmBhUjtgIAzgoAfwICDAAAFAAn8CPOClEgG1AbMEoASSAb8CfK
CjQgC3ClAwBuAAV6AwEZAAJPA0tgG-AjcAMBGwARC8YGGSNgAyJQG00LGHCeACIgG54AEWCECxAg
NAAKRgNDUEuACxsAFyIGATGQC1CoBgwyKxUypgY-MC4ypAoG8Q928AXW8AD2AsD2BKD2BoD2CGD2
CkD2DDD2DCD2DhADAEQA9vAADAARIBsA-wZA9gpg9giA9gag9gTA9gLwANbwBXbyAv9GFX-sAQCW
DDAQG0AGABBbzg0s8A74AiEbICACAGwCAgoAEkAEAxkNBAMABgAgYCvRBhFg1AIAGgAm8A2gBgFW
ABFgewYFIwA5G-ARnAYTMEoGIgAboQIDJQYAlAAEHgMQoBgDITswnABBIDswSwkDFw0kAxGgHgMC
PAATEEYAJBAbJwADMAMRsCoDEWDtDREglgY4QAtw0gBQIBuwG2D1DRErrQABkAAQIEIACD4DEsA6
AwQiAQF8BgEnABMMXgFQ0AtQWxD8DQGCBgFWBC--AKwBCx0zTQMvfxn2Cf_PE33wAUKQO1A7LA0w
AFtAVAM5K-AITgMRcB8QEVAMAAXwCQFaAyfwCU4DEXAIACAAC64MAhYAMkArQCUABFADWLAbgAsQ
IQADWgMAIwAFUgMgkDtrAADXDANrAANaAyXwCVADILAbKREDIwASS5oACUYAASMAJAswIwAB3AkC
WgMFjgBgoAvACzBr2AABAgMjG0BYAwfUADIgG3BpDQH-AATWCSFAKyUACFQDAScAQwtQG0BaDhFA
7gBFIAvwCGQBcyArMDsgO2DOCQBaESvw_7MBQzQxLjK2AQAKAA-tHP9YAQ8DGI0PAwEjFCbwJeUB
AwcDIEA7gQUBSQYbJPsCESBPCQBcBRAwHQAG8wJCUBtQG68FKfAo5wIAUwAQEKkFAGoABtsCExAX
AElgG-Ak0QIKGQAFxQITEGAAGHCUAAO7AgWUABAgNAAMswIgQEt9AxIgHwAYIwABIVsQ9wUbCUYB
JjE38Q8eMVoMD6wBEw8xAP--rfALgBrAGsAqsEqgSoAKEEpgKhAKCypQKhAKGyqvKP8QKyogKgAa
OyoQWksqECp7KiAaexowKlsaUCo7GoBaQJ0AHg8xAP8TtQVYgHhgmEC4INgQAgCvILhAmGB4gFjw
BX8AHg_lAf9NYigSOBIoEAYAUdgQWBJYBACfaAJYILhAKCI4tQEkDzEA------------EVBtPTR9
fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA2LTE4IDE1OjQxOjM5Iixtb2RpZmllZD0iMjAyNS0w
Ny0wMSAyMDo1MTo0MiJdXQ==
:: gods/
:: gods/blue_gods.lua
--[[pod_format="raw",created="2025-06-24 17:53:59",modified="2025-07-01 20:50:59",revision=382]]
velith_god=function(stats)
	ret= new_god(stats)
	ret.name="Velith"
	ret.title="The Eternal Shade"
	ret.sprite=68
	ret.description="+3 to all shades"
	ret.flavor="Every light casts a shadow. To kill the shades you must first kill the world"
	ret.color=colors.blue
	ret.color_boosts={0,0,3,0,0}
	ret.cost=3
	return ret
end
asul_god=function(stats)
	ret= new_god(stats)
	ret.name="Asul"
	ret.title="The Drowned Memory"
	ret.sprite=68
	ret.description="Adds 5 seconds to the move timer"
	ret.flavor="He knows all that has ever been forgotten"
	ret.color=colors.blue
	ret.color_boosts={0,0,1,0,0}
	ret.update_other_values= function(self)

		self.stats.movetimer_max+=5*60
	end
	return ret
end
noen_god=function(stats)
	ret= new_god(stats)
	ret.name="Noen"
	ret.title="The Echo Without Voice"
	ret.sprite=68
	ret.description="Adds 1 turn per trial"
	ret.flavor="The more one opens their mind to a paradox, the deeper the infection spreads"
	ret.color=colors.blue
	ret.color_boosts={0,0,1,0,0}
	ret.update_other_values= function(self)
		self.stats.moves_max+=1
	end
	return ret
end

kyreth_god=function(stats)
	ret= new_god(stats)
	ret.name="Kyreth"
	ret.title="The blue"
	ret.sprite=68
	ret.description="Allows one free move without creating matches."
	ret.flavor="Do not ask for what The Weeper cries"
	ret.color=colors.blue
	ret.uses=1
	ret.color_boosts={0,0,1,0,0}
	ret.score_matches=function(self,matches)
		if(self.uses>0 and  #matches==0 and self.stats.chain_counter==1 ) then
			self.stats:add_message(self.name..":Free move granted")
			game.moves-=1
			self.uses-=1
		end
	end	
	ret.reset_trial=function(self) 
		self.uses=1
	end
	return ret
end
caela_god=function(stats)
	ret= new_god(stats)
	ret.name="Caela"
	ret.title="The Dreamer of Ice"
	ret.sprite=68
	ret.description="match squares"
	ret.flavor="The nature of water is life. The nature of ice is death"
	ret.color=colors.blue
	ret.color_boosts={0,0,1,0,0}
	ret.update_other_values= function(self)
		self.stats.match_square=true
	end
	return ret
end
:: gods/god.lua
--[[pod_format="raw",created="2025-06-20 23:37:11",modified="2025-07-01 20:50:59",revision=1577]]
new_god=function(stats)
	return {
		name,
		title,
		sprite,
		description="",
		flavor="",
		color=0,
		stats=stats,
		cost=4,
		color_boosts={0,0,0,0,0},
		update_color_values=function(self) 
			for i=1,#self.color_boosts do
				self.stats.color_values[i]+=self.color_boosts[i]
			end
		end,
		update_combo_values=function(self) end,
		update_chain_values=function(self) end,
		update_other_values=function(self) end,
		reset_chain=function(self) end,
		reset_trial=function(self) end,
		score_matches=function(self,matches) end,
		init=function(self) end,
		update=function(self)
			self:update_color_values()
			self:update_combo_values()
			self:update_chain_values()
			self:update_other_values()
		end,
		match_length=function(self,n,matches)
			return n
		end,
		draw=function(self,offset)
			rectfill(offset.x,offset.y,offset.x+42,offset.y+48,32)
			if(self.color!=0) then 
				rect(offset.x+1,offset.y+1,offset.x+42-1,offset.y+48-1,self.color)
			end
			spr(self.sprite,offset.x+5,offset.y+12)
			print(self.name,offset.x+3,offset.y+3,6)
		end,
		draw_modal=function(self)
			rectfill(174,20,174+150,20+184,32)
			local offset=16
			for i=1,self.cost do
				spr(130,174+150-(i)*18,21)
			end
				
			print(self.name,176,24,7)
			print(self.title,176,38,6)
			spr(self.sprite, 235,54)
			local height=print_wrapped(self.description,new_point(180,100),140,7)
			print_wrapped(self.flavor,new_point(180,100+height+20),140,6)
			for i=1,#self.color_boosts	 do
				for j=1,self.color_boosts[i] do
					spr(i,174+148-offset,180)
					offset+=16
				end
			end
		end,
	}
end

new_base_god=function(stats)
	ret= new_god(stats)
	ret.chait_total=0
	ret.match_length=function(self,n,matches)
			return #matches-2
	end
	ret.score_matches=function(self,matches)
		if(#matches==0) then
			return
		end
		
		local match_length=self.stats:match_length(matches)
		local combo_value=self.stats.combo_values[match_length]
		--get average value	
		local tile_value_sum=0
		for _,match in  ipairs(matches) do		
			tile_value_sum+=self.stats.color_values[match.color]
		end	
		local average=tile_value_sum/#matches
		local points=flr(average*combo_value+.5)--round to nearest point
		local chain_mult=self.stats.chain_values[self.stats.chain_counter]	
		local chain_points= points*chain_mult
		self.stats.points+=chain_points
		self.stats.chain_counter+=1 
		self.stats:add_message(
			"value:"..flr(average).." x combo:"..combo_value.." x chain:"..chain_mult.." = "..chain_points)
		self.chait_total+=chain_points
	end
	ret.reset_chain=function(self)
		self.stats.chain_counter=1
		self.stats:add_message("chain total:"..self.chait_total,colors.white)
		self.chait_total=0
	end
	ret.update_color_values= function(self) --set values of all colors to 1
		self.stats.color_values={}
		for i = 1,5 do
			add(self.stats.color_values,1)
		end
	end
	ret.update_combo_values= function(self) --set values of all combos to n
		for i = 1,27 do --the first combo is 3
			add(self.stats.combo_values,i)
		end
	end
	ret.update_chain_values= function(self) --set values of all combos to n
		for i = 1,20 do 
			add(self.stats.chain_values,i)
		end
	end
	ret.update_other_values= function(self)
		self.stats.moves_max=5
		self.stats.movetimer_max=6*60
		self.stats.match_vertical=true
		self.stats.match_horizontal=true
	end
	return ret
end



:: gods/green_gods.lua
--[[pod_format="raw",created="2025-06-23 14:05:19",modified="2025-07-01 20:50:59",revision=506]]
vireth_god=function(stats)
	ret= new_god(stats)
	ret.name="Vireth"
	ret.title="The Emissary of Rot"
	ret.sprite=64
	ret.description="+3 to all rots"
	ret.flavor="The scent is the first thing you will sense, and the last thing you will forget"
	ret.color=colors.green
	ret.color_boosts={0,3,0,0,0}
	ret.cost=3
	return ret
end

egru_god=function(stats)
	ret= new_god(stats)
	ret.name="Egru"
	ret.title="The Mold Father"
	ret.sprite=67
	ret.description="+2 chain for chains above 3."
	ret.flavor="His children crumble stone, what are you made of?"
	ret.color=colors.green
	ret.color_boosts={0,1,0,0,0}
	ret.update_chain_values= function(self) --set values of all combos to n
		for i = 4,20 do 
			self.stats.combo_values[i]+=2
		end
	end
	return ret
end 
myru_god=function(stats)
	ret= new_god(stats)
	ret.name="Myru"
	ret.title="The Blooming Husk"
	ret.sprite=67
	ret.description="+3 chain for chains above 4."
	ret.flavor="Death feeds life, life feeds death"
	ret.color=colors.green
	ret.color_boosts={0,1,0,0,0}
	ret.update_chain_values= function(self) --set values of all combos to n
		for i = 5,20 do 
			self.stats.combo_values[i]+=3
		end
	end
	return ret
end 

beloth_god=function(stats)
	ret= new_god(stats)
	ret.name="Beloth"
	ret.title="The Allroot"
	ret.sprite=67
	ret.description="Gain 2 combo size for every additional color"
	ret.flavor="What you see is a fraction of a fraction of a fraction"
	ret.color=colors.green
	ret.color_boosts={0,1,0,0,0}
	ret.match_length=function(self,n,matches)
		local seen = {}
		for _, match in ipairs(matches) do
			seen[match.color] = true
		end
	
		local count = 0
		for _, used in pairs(seen) do
			if used then count += 1 end
		end
		if(count>1) then
			self.stats:add_message(self.name..":Combo extended by "..(count-1)*2)
			return n+(count-1)*2
		else
			return n
		end
	end
	return ret
end

grask_god=function(stats)
	ret= new_god(stats)
	ret.name="Grask"
	ret.title="The Fattened Leech"
	ret.sprite=67
	ret.description="Double the size of mono combos 4 or greater"
	ret.flavor="It prefers essence, it settles for blood"
	ret.color=colors.green
	ret.color_boosts={0,1,0,0,0}
	ret.match_length=function(self,n,matches)
		if(#matches<2) then
			return n
		end
		local c =matches[1].color
		for i=2, #matches do
			if(matches[i].color!=c) then
				return n
			end
		end
		self.stats:add_message(self.name..":Combo doubled")
		return (n+2)*2-2
	end
	return ret
end


:: gods/purple_gods.lua
--[[pod_format="raw",created="2025-06-25 13:46:31",modified="2025-07-01 20:50:59",revision=312]]
zuruth_god=function(stats)
	ret= new_god(stats)
	ret.name="zuruth"
	ret.title="The Mad Hollow"
	ret.sprite=69
	ret.description="+3 to all shades"
	ret.flavor="He is purple"
	ret.color=colors.purple
	ret.color_boosts={0,0,0,3,0}
	ret.cost=3
	return ret
end
meraxi_god=function(stats)
	ret= new_god(stats)
	ret.name="Neraxi"
	ret.title="The Dreaming Sloth"
	ret.sprite=69
	ret.description="Halfs time to move tiles. Score matches twice"
	ret.flavor="No one has ever seen it move, that means no one sees it coming for them"
	ret.color=colors.purple
	ret.color_boosts={0,0,0,1,0}
	ret.update_other_values= function(self)
		self.stats.movetimer_max/=2
	end
	ret.score_matches=function(self,matches)
		self.stats.chain_counter-=1 --we want to score it twice, not combo it twice
		self.stats.gods[1]:score_matches(matches)
	end
	return ret
end
ilmeth_god=function(stats)
	ret= new_god(stats)
	ret.name="Ilmeth"
	ret.title="The Oath Breaker "
	ret.sprite=69
	ret.description="Destroy a random god All scores are doubled"
	ret.flavor="There is a power to a contract.  Like with all things, to take that power one must destroy it"
	ret.color=colors.purple
	ret.color_boosts={0,0,0,1,0}
	ret.destroyed=false
	ret.update_color_values= function(self)
		if(self.destroyed) then
			self.stats.color_values[4]+=1
		else
			self.stats.color_values[4]=0
		end
	end
	ret.init=function(self)
		if(#self.stats.gods>2) then --there is more than the base joker, and him
			local n=flr(rnd(#self.stats.gods-1)+2)
			self.stats:add_message(self.name..":"..self.stats.gods[n].name .." has left")
			del(self.stats.gods,self.stats.gods[n])
			self.destroyed=true
			--self.stats:add_message(self.name..":A deal comes to an end")
		else
			self.stats:add_message(self.name..":A price paid in other ways")
		end
	end
	ret.score_matches=function(self,matches)
		self.stats.chain_counter-=1 --we want to score it twice, not combo it twice
		self.stats.gods[1]:score_matches(matches)
	end
	return ret
end
dreluun_god=function(stats)
	ret= new_god(stats)
	ret.name="Dreluun"
	ret.title="The Barter of Time"
	ret.sprite=69
	ret.description="Lose a move, Time is no longer a problem"
	ret.flavor="Unused gold builds interest. Unused time festers away"
	ret.color=colors.purple
	ret.color_boosts={0,0,0,1,0}
	ret.update_other_values= function(self)
		self.stats.movetimer_max=2147483647
		self.stats.moves_max-=1
	end
	return ret
end

soruun_god=function(stats)
	ret= new_god(stats)
	ret.name="Soruun"
	ret.title="The Melancholy"
	ret.sprite=69
	ret.description="Average all values"
	ret.flavor="At least you didn't try"
	ret.color=colors.purple

	ret.color_boosts={0,0,0,1,0}
	ret.update_other_stats= function(self)	
		local values = self.stats.color_values
		local sum = 0
		for _, v in ipairs(values) do
			sum += v
		end
		local avg = ceil(sum / #values)
		for i = 1, #values do
			values[i] = avg
		end		
	end
	return ret
end
:: gods/red_gods.lua
--[[pod_format="raw",created="2025-06-21 17:20:58",modified="2025-07-01 20:50:59",revision=968]]
malvex_god=function(stats)
	ret= new_god(stats)
	ret.name="Malvex"
	ret.title="The Wraith in Chains"
	ret.sprite=64
	ret.description="+3 to all wraiths"
	ret.flavor="No one knows who chained him. No one knows what will be when he is freed"
	ret.color=colors.red
	ret.color_boosts={3,0,0,0,0}
	ret.cost=3
	return ret
end

dravak_god=function(stats)
	ret= new_god(stats)
	ret.name="Dravak"
	ret.title="The Fire that Crawls"
	ret.sprite=65
	ret.description="Every time you achieve an x2, you have +1x for the rest of the trial"
	ret.flavor="All flame spreads. He may be slow, but he is inevitable"
	ret.color=colors.red
	ret.upgrades=0
	ret.color_boosts={1,0,0,0,0}
	ret.score_matches=function(self,matches)
		if(self.stats.chain_counter==3)then	--one more than shown
			self.upgrades+=1
			self.stats:add_message(self.name..":All values increased")
		end
	end
	ret.base_update_color_values=ret.base_update_color_values
	ret.update_color_values= function(self)
		self.base_update_color_values()
		for i = 1,5 do
			self.stats.color_values[i]+=self.upgrades
		end
	end
	ret.reset_trial=function(self) 
		self.upgrades=0
	end
	return ret
end 
skaza_god=function(stats)
	ret= new_god(stats)
	ret.name="Skaza"
	ret.title="The Red Maw"
	ret.sprite=72
	ret.description="+2 combo for combos above 3."
	ret.flavor="She chews for pleasure. It makes no difference to the furnace in her gizzard"
	ret.color=colors.red
	ret.color_boosts={1,0,0,0,0}
	ret.update_chain_values= function(self) --set values of all combos to n
		for i = 4,20 do 
			self.stats.chain_values[i]+=2
		end
	end
	return ret
end 


flarim_god=function(stats)
	ret= new_god(stats)
	ret.name="Flarim"
	ret.title="The Burning Echo"
	ret.sprite=73
	ret.description="+1 combo for combos above 2."
	ret.flavor="He is a reflection of all fires. All fires are a reflection of him"
	ret.color=colors.red
	ret.color_boosts={1,0,0,0,0}
	ret.update_chain_values= function(self) --set values of all combos to n
		for i = 3,20 do 
			self.stats.chain_values[i]+=1
		end
	end
	return ret
end
velcrith_god=function(stats)
	ret= new_god(stats)
	ret.name="Velcrith"
	ret.title="The Crimson Oath "
	ret.sprite=74
	ret.description="Increases the chain counter for combos of exactly 3"
	ret.flavor="Liar liar, soul's on fire"
	ret.color=colors.red
	ret.color_boosts={1,0,0,0,0}
	ret.score_matches=function(self,matches)
		if(#matches==3) then
			self.stats.chain_counter+=1 
			self.stats:add_message(self.name..":The chain grows stronger")
		end
	end
	return ret
end 	


--velcrith_god=function(stats)
--	ret= new_god(stats)
--	ret.name="Velcrith"
--	ret.title="The Crimson Oath "
--	ret.sprite=65
--	ret.description="Destroy tiles near combos"
--	ret.flavor="Liar liar, soul's on fire"
--	ret.color=colors.red
--	ret.base_score_matches=ret.score_matches
--	ret.upgrades=0
--	ret.score_matches=function(self,matches)
--		self:base_score_matches(matches)
--		if(self.stats.chain_counter>1)then	--one more than shown
--			for i =1 ,#matches do
--				local match=matches[i]
--				local bead=game.field.cup[match.position.x][match.position.y-1]
--				if(bead!=nil and bead.position.y>game.field.visible_rows + 1 and bead.matched==false) then
--					del(game.field.cup[match.position.x],bead)
--				end
--				
--			end
--		end
--	end
--	ret.update_color_values= function(self)
--		self.stats.color_values[1]+=1
--	end
--	return ret
--end 



:: gods/yellow_gods.lua
--[[pod_format="raw",created="2025-06-25 15:51:33",modified="2025-07-01 20:50:59",revision=212]]
yonvek_god=function(stats)
	ret= new_god(stats)
	ret.name="Yonvek"
	ret.title="The Blinding Wisp"
	ret.sprite=70
	ret.description="+3 to all wisps"
	ret.flavor="With enough light, your eyes will only see darkness"
	ret.color=colors.yellow
	ret.color_boosts={0,0,0,0,3}
	ret.cost=3
	return ret
end

thimel_god=function(stats)
	ret= new_god(stats)
	ret.name="Thimel"
	ret.title="The Spark in the Abyss "
	ret.sprite=70
	ret.description="Prevent death once"
	ret.flavor="Do not ask why you were granted one mercey"
	ret.color=colors.yellow
	ret.color_boosts={0,0,0,0,1}
	ret.init=function(self)
		self.stats.lives+=1
	end	

	return ret
end
vollun_god=function(stats)
	ret= new_god(stats)
	ret.name="Vollun"
	ret.title="The Last Ember"
	ret.sprite=70
	ret.description="If this is your last move for a trial, all scores are quadrupled"
	ret.flavor="Hope, Pray, Beg. What names will you invoke when you think it is your last hour?"
	ret.color=colors.yellow
	ret.color_boosts={0,0,0,0,1}
	ret.score_matches=function(self,matches)
		if(self.stats.moves_max==game.moves)then
			self.stats:add_message(self.name..":A gift has been given")
			self.stats.chain_counter-=1 --we want to score it twice, not combo it twice
			self.stats.gods[1]:score_matches(matches)
			self.stats.chain_counter-=1 --we want to score it twice, not combo it twice
			self.stats.gods[1]:score_matches(matches)
			self.stats.chain_counter-=1 --we want to score it twice, not combo it twice
			self.stats.gods[1]:score_matches(matches)
		end
	end
	return ret
end

nethir_god=function(stats)
	ret= new_god(stats)
	ret.name="Nethir"
	ret.title="The Shepherd of the Zealous"
	ret.sprite=70
	ret.description="A line across matches all"
	ret.flavor="When the blind leads the blind leads the blind, who knows who stands in the front?"
	ret.color=colors.yellow
	ret.color_boosts={0,0,0,0,1}
	ret.score_matches=function(self,matches)	
		local row_counts = {}	
		for _, bead in ipairs(matches) do
			local y = bead.position.y
			row_counts[y] = (row_counts[y] or 0) + 1
		end
		for _, count in pairs(row_counts) do
			if count >= 6 then
				self.stats:add_message(self.name..":A line is formed")
				self.stats.chain_counter-=1 
				local new_matches={}
				for x = 1, game.field.width do
					for y = game.field:match_start(), game.field.total_height do
						local bead = game.field.cup[x][y]
						if bead and bead.matched==false then
							bead.matched = true
							add(new_matches,bead)
						end
					end
				end
				self.stats.gods[1]:score_matches(new_matches)
				return --we only need to do this once
			end
		end
	end
	return ret
end

ezeleth_god=function(stats)
	ret= new_god(stats)
	ret.name="Ezeleth"
	ret.title="The Beacon to the Lost"
	ret.sprite=70
	ret.description="When 5 yellow are matched, 50% chance for each bead to become yellow. Only once per move"
	ret.flavor="In the dark, are you any different than an insect? Will not any light do?"
	ret.color=colors.yellow
	ret.uses=1
	ret.color_boosts={0,0,0,0,1}
	ret.reset_chain=function(self) 
		self.uses=1
	end
	ret.score_matches=function(self,matches)
		if(self.uses>0) then
			self.uses-=1
			local counter=0
			for _, bead in ipairs(matches) do
				if(bead.color==5) then
					counter+=1
				end
			end
			if(counter>=5) then
				self.stats:add_message(self.name..":The light spreads")
				local dummy= new_yellow_bead(new_point(0,0),new_point(0,0))
				for x = 1, game.field.width do
					for y = game.field:match_start(), game.field.total_height do
						if(rnd(1)>0.5) then
							local bead = game.field.cup[x][y]
							bead.color=dummy.color
							bead.sprites=dummy.sprites
							bead.death_anim=dummy.death_anim

						end
						
					end
				end
			end
		end
	end
	return ret
end

:: gods/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA2LTIxIDE3OjAyOjMyIixtb2RpZmllZD0iMjAyNS0w
Ny0wMSAyMDo1MTo0MiJdXQ==
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA2LTE4IDEyOjEzOjQ0Iixtb2RpZmllZD0iMjAyNS0w
Ny0wMSAyMDo1MDo1OSIscmV2aXNpb249MTkwMV1dbHo0AIsAAABqBAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwxNgMALyIwAQCLLzEwAQArLzIwAQArLzMwAQArLzQwAQADLzUwAQATLzUwAQD--07x
CyIpLGhpZGRlbj1mYWxzZSxwYW5feD0zMi41CwCFeT0tNzIuMTYBALI3LHRpbGVfaD0xNgoAEHcK
AIB6b29tPTJ9fQ==
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA2LTE4IDE1OjQxOjM5Iixtb2RpZmllZD0iMjAyNS0w
Ny0wMSAyMDo1MTo0MiJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA2LTE4IDEyOjEzOjQ0Iixtb2RpZmllZD0iMjAyNS0w
Ny0wMSAyMDo1MDo1OSIscmV2aXNpb249MTg4M11dbHo0AN0AAAAtCgAA-zBweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDQA8PkAQFBgdADJAICQoLQAyQDwwPDQ8ODEAM8P8BAOvxA6oB
EAYPIBABIAEgAfAADxIQAg4A_S0PJQ-mD-8RMA9AkAEIIA9QIA9ZEAIPK-CrDygPa8ABcA8ZEArw
rA-4Cg--D4AP9w8NAXAPZg9JD1IPRcBSAEACEAIOUADoISABMA9A8MMPKA--8MY5AG-wCQEQBg4w
AP------jR--AQCsz8gPQAAPEED--7Dw-wEA-_pQ-----yk=
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA2LTE4IDE1OjQxOjM5Iixtb2RpZmllZD0iMjAyNS0w
Ny0wMSAyMDo1MTo0MiJdXQ==
:: bead.lua
--[[pod_format="raw",created="2025-06-18 13:37:09",modified="2025-06-27 14:29:25",revision=1842]]
beadid=0

function new_bead(offset,position)
	return{
		id=-1,
		color=0,
		sprites={},
		death_anim={},
		death_anim_countdown=16,	
	
		offset=offset,
		position=position:clone(),
		
		visual_position=position:clone(),	
		sub_position=new_point(0,0),
		matched=false,	
		init=function(self)
			self.death_anim_countdown=16
			self.id=beadid
			beadid+=1
		end,
		update=function(self)
			if(	self.matched ) then
				self.death_anim_countdown-=1
				return self.death_anim_countdown>0
			else
		 		if(self.visual_position:equals(self.position)==false) then
		 			self.visual_position.x+=sign(self.position.x-self.visual_position.x)/tileSize
		 			self.visual_position.y+=sign(self.position.y-self.visual_position.y)/tileSize
			 		return true
		 		end
		 		return false
		 	end
			pq("wtf?")
		end,
		draw=function(self)
			if(self.visual_position.y>3) then
				if(	self.matched) then
					local sprite=self.death_anim[ceil( (16-self.death_anim_countdown)/4)]
					spr(sprite,
					self.offset.x+(self.visual_position.x-1)*tileSize,
					self.offset.y+(self.visual_position.y-1)*tileSize)
				else
					local sprite=get_frame(self.sprites,10)

					spr(sprite,
					self.offset.x+(self.visual_position.x-1)*tileSize,
					self.offset.y+(self.visual_position.y-1)*tileSize)
				
				end
--				if(self.matched) then
--					spr(16,
--						self.offset.x+(self.visual_position.x-1)*tileSize,
--						self.offset.y+(self.visual_position.y-1)*tileSize+self.sub_position.y)
--				end
--				print(self.id,	self.offset.x+(self.visual_position.x-1)*tileSize+3,
--				self.offset.y+(self.visual_position.y-1)*tileSize+5+self.sub_position.y,0)
			end
		end,	
--		draw=function(self)
--
--			spr(self.sprites[1],
--			self.offset.x+(self.position.x-1)*tileSize,
--			self.offset.y+(self.position.y-1)*tileSize)
--			if(self.matched) then
--			spr(16,
--				self.offset.x+(self.position.x-1)*tileSize,
--				self.offset.y+(self.position.y-1)*tileSize)
--			end
--			print(self.id,	self.offset.x+(self.position.x-1)*tileSize+3,
--			self.offset.y+(self.position.y-1)*tileSize+5,0)
--		end,	
		
	}
end

function new_red_bead(offset,position)
	local ret= new_bead(offset,position)
	ret.color=1
	ret.sprites={1,9,17,25,17,9,1}
	ret.death_anim={33,41,49,57}
	return ret
end
function new_green_bead(offset,position)
	local ret= new_bead(offset,position)
	ret.color=2
	ret.sprites={2,10,18,26,18,10,2}
	ret.death_anim={34,42,50,58}	
	return ret
end
function new_blue_bead(offset,position)
	local ret= new_bead(offset,position)
	ret.color=3
	ret.sprites={3,11,19,27,19,11,3}
	ret.death_anim={35,43,51,69}
	return ret
end
function new_purple_bead(offset,position)
	local ret= new_bead(offset,position)
	ret.color=4
	ret.sprites={4,12,20,28,20,12,4}
	ret.death_anim={36,44,52,70}
	return ret
end
function new_yellow_bead(offset,position)
	local ret= new_bead(offset,position)
	ret.color=5
	ret.sprites={5,13,21,29}
	ret.death_anim={37,45,53,71}	
	return ret
end
bead_bank={new_red_bead,
new_green_bead,new_blue_bead,
new_purple_bead,new_yellow_bead
}
:: camera.lua
--[[pod_format="raw",created="2025-06-18 13:01:48",modified="2025-06-18 20:03:06",revision=392]]
camera_helper={
camera_point =new_point(0,0),
camera_desired_point =new_point(0,0),
camera_shake =new_point(0,0),
shake_intensity=0,
shake_timer=0,
shake_time=0,
camera_shake =new_point(0,0),
-- Function to set the camera position and update the variables
set_camera=function(self,point,instant)
		self.camera_desired_point=point
	if(instant) then
		self.camera_point=point
	end

end,
get_camera=function(self)
    return self.camera_point
end,	
update_camera=function(self)
	self.camera_point=self.camera_point:lerp(self.camera_desired_point,0.5)
	 self:calculate_shake()
	local c=self.camera_point+self.camera_shake
	 camera(c.x, c.y)
end,

shake_camera= function(self,intensity, t )
	self.shake_intensity=intensity
	self.shake_timer=t
	self.shake_time=t
end,
calculate_shake = function(self)
	if(self.shake_timer>0) then		
		local strength=self.shake_intensity*self.shake_timer/self.shake_time
		local point=new_point(random(-1)*strength,random(-1)*strength)
		self.camera_shake=self.camera_shake:lerp(point,0.5)
		self.shake_timer-=1
	else
		self.camera_shake =new_point(0,0)
	end
end
}
:: cursor.lua
--[[pod_format="raw",created="2025-06-19 02:43:31",modified="2025-06-23 17:21:40",revision=774]]
function new_cursor(offset,position)
	return{
		sprites={8,16},
		offset=offset,
		position=position,
		init=function(self)			
		end,		
		update=function(self)
			local old_pos=self.position:clone()
			if input:button_press(input_lookup.lpad.left) then 
				self.position.x=mid(1, self.position.x-1,6)
			elseif input:button_press(input_lookup.lpad.right) then 
				self.position.x=mid(1, self.position.x+1,6)			
			elseif input:button_press(input_lookup.lpad.up) then 
				self.position.y=mid(6, self.position.y-1,10)
			elseif input:button_press(input_lookup.lpad.down) then 
				self.position.y=mid(6, self.position.y+1,10)
			end
			if(self.position:equals(old_pos)==false) then
				if(game.state==1) then
					game.field:swap(old_pos,self.position)
				end
			end

		end,
		draw=function(self)
			if(game.state==1) then
				spr(self.sprites[2],
						self.offset.x+(self.position.x-1)*tileSize,
						self.offset.y+(self.position.y-1)*tileSize)	
			else			
				spr(self.sprites[1],
						self.offset.x+(self.position.x-1)*tileSize,
						self.offset.y+(self.position.y-1)*tileSize)
			end
		end,	
	}
end
:: error_explorer.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNS0wNi0xOCAxMjo0OTowMiIsbW9k
aWZpZWQ9IjIwMjUtMDYtMTggMjA6MjQ6NTIiLHJldmlzaW9uPTQ0OF1dCi0tICMgcGljb3Ryb24g
ZXJyb3IgZXhwbG9yZXIKLS0KLS0gYnkga2lyYQotLQotLSB2ZXJzaW9uIDAuMC42Ci0tCi0tIGFu
IGludGVyYWN0aXZlIGVycm9yIHNjcmVlbiBmb3IgcGljb3Ryb24uCi0tIG9uIGVycm9yLCBzaG93
cyB0aGUgc3RhY2ssIGxvY2FsIHZhcmlhYmxlcywKLS0gYW5kIHRoZSBzb3VyY2UgY29kZSB3aGVu
IGF2YWlsYWJsZS4KLS0KLS0gIyMgdXNhZ2UKLS0KLS0gYGluY2x1ZGVgIG9yIGByZXF1aXJlYCBg
ZXJyb3JfZXhwbG9yZXIubHVhYAotLSBpbiB5b3VyIHByb2dyYW0gX2FmdGVyXyBkZWZpbmluZyB5
b3VyIGBfaW5pdGAsCi0tIGBfdXBkYXRlYCwgYW5kIGBfZHJhd2AgZnVuY3Rpb25zLgotLQotLSBw
cmVzcyBgdXBgIGFuZCBgZG93bmAgdG8gbW92ZSB1cCBhbmQgZG93biBvbgotLSB0aGUgc3RhY2ss
IHByZXNzIGB4YCBvciBgc3BhY2VgIHRvIHRvZ2dsZSBmb250Ci0tIHNpemUuIGNsaWNrIG9uIHRh
YmxlcyBpbiB0aGUgdmFyaWFibGUgdmlldyB0bwotLSBleHBhbmQgdGhlbS4KLS0KLS0gIyMgaG93
IGl0IHdvcmtzCi0tCi0tIGluIG9yZGVyIHRvIGNhdGNoIGVycm9ycyBhbmQgaW5zcGVjdCBydW50
aW1lCi0tIHN0YXRlLCB0aGlzIHNjcmlwdCByZXBsYWNlcyBgX2luaXRgLCBgX3VwZGF0ZWAKLS0g
YW5kIGBfZHJhd2AgZnVuY3Rpb25zIHdpdGggb25lcyB0aGF0IGNhbGwgdGhlCi0tIG9yaWdpbmFs
IG9uZXMgaW5zaWRlIGEgY29yb3V0aW5lLgotLQotLSB3aGVuIHRoZXJlJ3MgYW4gZXJyb3IsIGl0
IHVzZXMgbHVhJ3MgZGVidWcKLS0gbGlicmFyeSB0byBpbnNwZWN0IHRoZSBjb3JvdXRpbmUuIGEg
Y29weQotLSBvZiB0aGUgZXJyb3IgaXMgYWxzbyBwcmludGVkIHRvIHRoZSBjb25zb2xlCi0tIHdp
dGggcHJpbnRoIGlmIHlvdSdyZSBydW5uaW5nIHBpY290cm9uIGZyb20KLS0gdGhlIGNvbW1hbmQg
bGluZS4KLS0KLS0gdGhlIGZvbGxvd2luZyBkZWJ1ZyBhcGlzIGFyZSB1c2VkOgotLQotLSAtIGBk
ZWJ1Zy5nZXRpbmZvYAotLSAtIGBkZWJ1Zy5nZXRsb2NhbGAKLS0gLSBgZGVidWcuZ2V0dXB2YWx1
ZWAKLS0gLSBgZGVidWcudHJhY2ViYWNrYAotLQotLSAjIyB2ZXJzaW9uIGhpc3RvcnkgCi0tCi0t
IHZlcnNpb24gMC4wLjYKLS0gLSBvbiBlcnJvcjoKLS0gICAtIHNob3cgY3Vyc29yCi0tICAgLSBt
YWtlIHdpbmRvdyByZXNpemFibGUKLS0gLSBhdXRvbWF0aWNhbGx5IGFkanVzdCBsYXlvdXQgdG8g
d2luZG93IHNpemUKLS0gLSBzdXBwb3J0IHlpZWxkaW5nIChzaW5jZSBmZXRjaCBzb21ldGltZXMg
eWllbGRzKQotLQotLSB2ZXJzaW9uIDAuMC41Ci0tCi0tIC0gZnV0dXJlIHByb29maW5nOiBncmFj
ZWZ1bGx5IGhhbmRsZSB3aGVuCi0tICAgdmFyaW91cyBwYXJ0cyBvZiB0aGUgYGRlYnVnYCBtb2R1
bGUgYXJlbid0Ci0tICAgYXZhaWxhYmxlCi0tCi0tIHZlcnNpb24gMC4wLjQKLS0KLS0gLSBhbHNv
IGNhdGNoIGVycm9ycyBpbiBgX2luaXRgCi0tCi0tIHZlcnNpb24gMC4wLjMKLS0KLS0gLSBhdXRv
bWF0aWNhbGx5IGNob29zZSB0aGUgcmlnaHQgc3RhY2sgZnJhbWUKLS0gICBiYXNlZCBvbiB0aGUg
ZXJyb3IgbWVzc2FnZQotLSAtIG1vcmUgdGhvcm91Z2hseSBwcm90ZWN0IGZyb20gZXJyb3JzIGlu
IGVycm9yCi0tICAgZXhwbG9yZXIgaXRzZWxmCi0tCi0tIHZlcnNpb24gMC4wLjIKLS0KLS0gLSBk
b24ndCByZWdlbmVyYXRlIHN0YWNrIGluZm8gZXZlcnkgZHJhdwotLSAtIHNjcm9sbCBzdGFjayBh
bmQgdmFyaWFibGVzIGxpc3Qgd2l0aCBtb3VzZXdoZWVsCi0tIC0gY2xpY2sgb24gc3RhY2sgdG8g
c3dpdGNoIHN0YWNrIGZyYW1lcwotLSAtIGNsaWNrIG9uIHRhYmxlcyBpbiB2YXJpYWJsZXMgdmll
dyB0byBleHBhbmQgdGhlbQotLSAtIGVzY2FwZSBzdHJpbmdzIHdoZW4gcHJpbnRpbmcgdGhlbQot
LQotLSB2ZXJzaW9uIDAuMC4xCi0tCi0tIC0gYWRqdXN0IGNvbG9ycwotLSAtIGNvZGUgY2xlYW51
cAotLSAtIHVzZSBgYnRucGAgaW5zdGVhZCBvZiBga2V5cGAKLS0gLSBzbGlnaHRseSBtb3JlIHRo
b3JvdWdoIGByZXNldGAKLS0gLSBkb24ndCBzaG93IHRlbXBvcmFyaWVzCi0tCi0tIHZlcnNpb24g
MC4wLjAgKHByZXJlbGVhc2UpCi0tCi0tIC0gaW5pdGlhbCBkaXNjb3JkIGJldGEKCi0tICMjIGxp
Y2Vuc2UKLS0KLS0gQ29weXJpZ2h0IDIwMjQgS2lyYSBCb29tCi0tIAotLSBQZXJtaXNzaW9uIGlz
IGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcg
YSBjb3B5Ci0tIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBm
aWxlcyAodGhlIOKAnFNvZnR3YXJl4oCdKSwgdG8KLS0gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0
aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUKLS0gcmln
aHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3Vi
bGljZW5zZSwgYW5kL29yCi0tIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBl
cm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzCi0tIGZ1cm5pc2hlZCB0byBkbyBz
bywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6Ci0tCi0tIFRoZSBhYm92ZSBj
b3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1
ZGVkIGluCi0tIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3
YXJlLgotLSAKLS0gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIOKAnEFTIElT4oCdLCBXSVRIT1VU
IFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTCi0tIE9SIElNUExJRUQsIElOQ0xVRElORyBC
VVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLAotLSBG
SVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBO
TyBFVkVOVCBTSEFMTAotLSBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFC
TEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUgotLSBMSUFCSUxJVFksIFdIRVRIRVIg
SU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORwotLSBG
Uk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNF
IE9SIE9USEVSCi0tIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KCi0tLS0gdXRpbCAtLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpsb2NhbCBmdW5jdGlvbiBmaWxlbmFt
ZV9vZiAocGF0aCkKICByZXR1cm4gcGF0aDptYXRjaCAoJ1teL10qJCcpCmVuZAoKbG9jYWwgZnVu
Y3Rpb24gc2FmZV90b3N0cmluZyAodmFsdWUpCiAgaWYgdHlwZSAodmFsdWUpID09ICdzdHJpbmcn
IHRoZW4KICAgIHJldHVybiBzdHJpbmcuZm9ybWF0ICgnJXEnLCB2YWx1ZSkKICBlbHNlCiAgICBs
b2NhbCBzdWNjZXNzLCB2YWx1ZV9zdHJpbmcgPSBwY2FsbCAodG9zdHJpbmcsIHZhbHVlKQogICAg
cmV0dXJuIHN1Y2Nlc3MgYW5kIHZhbHVlX3N0cmluZwogICAgICAgICAgICAgICAgICAgb3IgKCdl
cnJvciBkdXJpbmcgdG9zdHJpbmc6ICcgLi4gdG9zdHJpbmcgKHZhbHVlX3N0cmluZykpCiAgZW5k
CmVuZAoKbG9jYWwgZnVuY3Rpb24gZ2V0X2xpbmVzICh0ZXh0KQogIGxvY2FsIGxpbmVzID0ge30K
ICBmb3IgbGluZSBpbiB0ZXh0OmdtYXRjaCAoIiguLSlccj9cbiIpIGRvCiAgICB0YWJsZS5pbnNl
cnQgKGxpbmVzLCBsaW5lKQogIGVuZAogIGxvY2FsIGxhc3RfbGluZSA9IHRleHQ6bWF0Y2ggKCco
W15cbl0qKSQnKQogIGlmIGxhc3RfbGluZSBhbmQgbGFzdF9saW5lIH49ICcnIHRoZW4KICAgIHRh
YmxlLmluc2VydCAobGluZXMsIGxhc3RfbGluZSkKICBlbmQKICByZXR1cm4gbGluZXMKZW5kCgps
b2NhbCBmdW5jdGlvbiBjb21wYXJlX2tleXMgKGEsIGIpCiAgbG9jYWwgdGEgPSB0eXBlIChhLmtl
eSkKICBsb2NhbCB0YiA9IHR5cGUgKGIua2V5KQogIGlmIHRhIH49IHRiIHRoZW4KICAgIHJldHVy
biB0YSA8IHRiCiAgZW5kCiAgaWYgdGEgPT0gJ251bWJlcicgb3IgdGEgPT0gJ3N0cmluZycgdGhl
bgogICAgcmV0dXJuIGEua2V5IDwgYi5rZXkKICBlbHNlCiAgICByZXR1cm4gc2FmZV90b3N0cmlu
ZyAoYS5rZXkpIDwgc2FmZV90b3N0cmluZyAoYi5rZXkpCiAgZW5kCmVuZAoKbG9jYWwgZnVuY3Rp
b24gc29ydCAodCwgZikKICAtLSBpbnNlcnRpb24gc29ydAogIGYgPSBmIG9yIGZ1bmN0aW9uIChh
LCBiKSByZXR1cm4gYSA8IGIgZW5kCiAgZm9yIGkgPSAxLCAjdC0xIGRvCiAgICBsb2NhbCB2YWwg
PSB0W2krMV0KICAgIGxvY2FsIGogPSBpCiAgICB3aGlsZSBqID49IDEgYW5kIG5vdCBmKHRbal0s
IHZhbCkgZG8KICAgICAgdFtqKzFdID0gdFtqXQogICAgICBqID0gaiAtIDEKICAgIGVuZAogICAg
dFtqKzFdID0gdmFsCiAgZW5kCmVuZAoKbG9jYWwgZnVuY3Rpb24gYXBwcm9hY2ggKGZyb20sIHRv
KQogIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiAwLjI1CmVuZAoKbG9jYWwgZnVuY3Rpb24g
cm91bmQgKHZhbHVlKQogIHJldHVybiBtYXRoLmZsb29yICh2YWx1ZSArIDAuNSkKZW5kCgpsb2Nh
bCBmdW5jdGlvbiBwYXJzZV9tZXNzYWdlX2Zvcl9sb2NhdGlvbiAobXNnKQogIGxvY2FsIHBhdGgs
IGxpbmUsIGVyciA9IG1zZzptYXRjaCAoJ14oW146XSspOiglZCspOiguKikkJykKICByZXR1cm4g
cGF0aCwgdG9udW1iZXIgKGxpbmUpLCBlcnIKZW5kCgotLS0tIHN0YXRlIC0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKbG9jYWwgX0cgPSBfRwpsb2NhbCBlcnJvcl9tZXNz
YWdlCmxvY2FsIGVycm9yX3RocmVhZApsb2NhbCBlcnJvcl90cmFjZWJhY2sKbG9jYWwgaW5pdF9k
b25lID0gZmFsc2UKbG9jYWwgdXNlX3NtYWxsX2ZvbnQgPSBmYWxzZQpsb2NhbCBtb3VzZV93YXNf
Y2xpY2tlZCA9IGZhbHNlCgotLSBzdGFjayB2aWV3CmxvY2FsIHN0YWNrX2ZyYW1lcyA9IHt9Cmxv
Y2FsIGN1cnJlbnRfc3RhY2tfaW5kZXggPSAxCmxvY2FsIGhvdmVyZWRfc3RhY2tfaW5kZXggPSBm
YWxzZQpsb2NhbCBtb3VzZV9vdmVyX3N0YWNrID0gZmFsc2UKbG9jYWwgc3RhY2tfbWF4X3Njcm9s
bCA9IDAKbG9jYWwgc3RhY2tfc2Nyb2xsID0gMApsb2NhbCBzdGFja19zY3JvbGxfc21vb3RoID0g
MAoKLS0gdmFyaWFibGVzIHZpZXcKbG9jYWwgdmFyaWFibGVzID0ge30KbG9jYWwgaG92ZXJlZF92
YXJpYWJsZSA9IGZhbHNlCmxvY2FsIHZhcmlhYmxlc19tYXhfc2Nyb2xsID0gMApsb2NhbCB2YXJp
YWJsZXNfc2Nyb2xsID0gMApsb2NhbCB2YXJpYWJsZXNfc2Nyb2xsX3Ntb290aCA9IDAKbG9jYWwg
bW91c2Vfb3Zlcl92YXJpYWJsZXMgPSBmYWxzZQoKLS0gc291cmNlIHZpZXcKbG9jYWwgc291cmNl
X2xpbmVzID0ge30KCgotLS0tIG1haW4gZXZlbnRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLQoKbG9jYWwgZnVuY3Rpb24gcmVidWlsZCAoKQogIC0tIHJlYnVpbGQgc3RhY2sgZnJh
bWUgaW5mbwogIHN0YWNrX2ZyYW1lcyA9IHt9CiAgdmFyaWFibGVzID0ge30KICBzb3VyY2VfbGlu
ZXMgPSB7fQogIHZhcmlhYmxlc19zY3JvbGwgPSAwCiAgdmFyaWFibGVzX3Njcm9sbF9zbW9vdGgg
PSAwCgogIGZvciBpID0gMCwgMjAgZG8KICAgIGxvY2FsIGluZm8gPSBkZWJ1Zy5nZXRpbmZvIChl
cnJvcl90aHJlYWQsIGkpCiAgICBpZiBub3QgaW5mbyB0aGVuCiAgICAgIGJyZWFrCiAgICBlbmQK
CiAgICBpZiBpbmZvLnNob3J0X3NyYyB0aGVuCiAgICAgIHRhYmxlLmluc2VydCAoc3RhY2tfZnJh
bWVzLCB7CiAgICAgICAgZmlsZW5hbWUgPSBmaWxlbmFtZV9vZiAoaW5mby5zaG9ydF9zcmMpLAog
ICAgICAgIHBhdGggPSBpbmZvLnNob3J0X3NyYywKICAgICAgICBsaW5lID0gaW5mby5jdXJyZW50
bGluZSwKICAgICAgICBkZXB0aCA9IGksCiAgICAgICAgZm5fbmFtZSA9IChpbmZvLm5hbWUgb3Ig
KGZpbGVuYW1lX29mIChpbmZvLnNob3J0X3NyYykgLi4gJzonIC4uIHRvc3RyaW5nIChpbmZvLmxp
bmVkZWZpbmVkKSkpLAogICAgICAgIHNvdXJjZSA9IGluZm8uc291cmNlLAogICAgICB9KQogICAg
ZW5kCiAgZW5kCgogIGxvY2FsIGZyYW1lID0gc3RhY2tfZnJhbWVzIFtjdXJyZW50X3N0YWNrX2lu
ZGV4XQoKICBpZiBub3QgZnJhbWUgdGhlbgogICAgcmV0dXJuCiAgZW5kCgogIC0tIHJlYnVpbGQg
dmFyaWFibGVzCiAgZG8KICAgIGlmIGRlYnVnLmdldGxvY2FsIHRoZW4KICAgICAgbG9jYWwgbG9j
YWxfaW5kZXggPSAxCiAgICAgIHJlcGVhdAogICAgICAgIGxvY2FsIG5hbWUsIHZhbHVlID0gZGVi
dWcuZ2V0bG9jYWwgKGVycm9yX3RocmVhZCwgZnJhbWUuZGVwdGgsIGxvY2FsX2luZGV4KQogICAg
ICAgIGlmIG5hbWUgdGhlbgogICAgICAgICAgaWYgbmFtZSB_PSAnKHRlbXBvcmFyeSknIHRoZW4K
ICAgICAgICAgICAgdGFibGUuaW5zZXJ0ICh2YXJpYWJsZXMsIHsKICAgICAgICAgICAgICBrZXkg
PSBuYW1lLAogICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUsCiAgICAgICAgICAgIH0pCiAgICAg
ICAgICBlbmQKICAgICAgICAgIGxvY2FsX2luZGV4ID0gbG9jYWxfaW5kZXggKyAxCiAgICAgICAg
ZW5kCiAgICAgIHVudGlsIG5vdCBuYW1lCiAgICBlbHNlCiAgICAgIHRhYmxlLmluc2VydCAodmFy
aWFibGVzLCB7CiAgICAgICAgZXJyb3IgPSAnbm8gZGVidWcuZ2V0bG9jYWwsIGNhblwndCBzaG93
IGxvY2FscycKICAgICAgfSkKICAgIGVuZAoKICAgIGlmIGRlYnVnLmdldHVwdmFsdWUgdGhlbgog
ICAgICBsb2NhbCBpbmZvID0gZGVidWcuZ2V0aW5mbyAoZXJyb3JfdGhyZWFkLCBmcmFtZS5kZXB0
aCkKICAgICAgaWYgaW5mbyBhbmQgaW5mby5mdW5jIHRoZW4KICAgICAgICBsb2NhbCB1cHZhbHVl
X2luZGV4ID0gMQogICAgICAgIHJlcGVhdAogICAgICAgICAgbG9jYWwgbmFtZSwgdmFsdWUgPSBk
ZWJ1Zy5nZXR1cHZhbHVlIChpbmZvLmZ1bmMsIHVwdmFsdWVfaW5kZXgpCiAgICAgICAgICBpZiBu
YW1lIHRoZW4KICAgICAgICAgICAgdGFibGUuaW5zZXJ0ICh2YXJpYWJsZXMsIHsKICAgICAgICAg
ICAgICBrZXkgPSBuYW1lLAogICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUsCiAgICAgICAgICAg
IH0pCiAgICAgICAgICAgIHVwdmFsdWVfaW5kZXggPSB1cHZhbHVlX2luZGV4ICsgMQogICAgICAg
ICAgZW5kCiAgICAgICAgdW50aWwgbm90IG5hbWUKICAgICAgZW5kCiAgICBlbHNlCiAgICAgIHRh
YmxlLmluc2VydCAodmFyaWFibGVzLCB7CiAgICAgICAgZXJyb3IgPSAnbm8gZGVidWcuZ2V0dXB2
YWx1ZSwgY2FuXCd0IHNob3cgdXB2YWx1ZXMnCiAgICAgIH0pCiAgICBlbmQKICBlbmQKCiAgLS0g
cmVidWlsZCBzb3VyY2UgbGluZXMKICBsb2NhbCBzb3VyY2UgPSBmcmFtZS5zb3VyY2UKICBpZiBz
b3VyY2UgdGhlbgogICAgaWYgc3RyaW5nLnN1YiAoc291cmNlLCAxLCAxKSA9PSAnQCcgdGhlbgog
ICAgICBsb2NhbCBmaWxlbmFtZSA9IHN0cmluZy5zdWIgKHNvdXJjZSwgMiwgI3NvdXJjZSkKICAg
ICAgc291cmNlID0gZmV0Y2ggKGZpbGVuYW1lKQogICAgZW5kCiAgICBpZiBzb3VyY2UgYW5kIHR5
cGUgKHNvdXJjZSkgPT0gJ3N0cmluZycgdGhlbgogICAgICBzb3VyY2VfbGluZXMgPSBnZXRfbGlu
ZXMgKHNvdXJjZSkKICAgIGVuZAogIGVuZAplbmQKCmxvY2FsIGZ1bmN0aW9uIGVycm9yX3VwZGF0
ZSAoKQogIGxvY2FsIGxhc3RfaW5kZXggPSBjdXJyZW50X3N0YWNrX2luZGV4CiAgaWYgYnRucCAo
NSkgb3Iga2V5cCAnc3BhY2UnIHRoZW4KICAgIHVzZV9zbWFsbF9mb250ID0gbm90IHVzZV9zbWFs
bF9mb250CiAgZW5kCiAgaWYgYnRucCAoMikgdGhlbgogICAgY3VycmVudF9zdGFja19pbmRleCA9
IG1hdGgubWF4ICgxLCBjdXJyZW50X3N0YWNrX2luZGV4IC0gMSkKICAgIHN0YWNrX3Njcm9sbCA9
IG1hdGgubWluIChjdXJyZW50X3N0YWNrX2luZGV4LTEsIHN0YWNrX3Njcm9sbCkKICBlbmQKICBp
ZiBidG5wICgzKSB0aGVuCiAgICBjdXJyZW50X3N0YWNrX2luZGV4ID0gbWF0aC5taW4gKCNzdGFj
a19mcmFtZXMsIGN1cnJlbnRfc3RhY2tfaW5kZXggKyAxKQogICAgc3RhY2tfc2Nyb2xsID0gbWF0
aC5tYXggKChjdXJyZW50X3N0YWNrX2luZGV4KSAtICgjc3RhY2tfZnJhbWVzIC0gc3RhY2tfbWF4
X3Njcm9sbCksIHN0YWNrX3Njcm9sbCkKICBlbmQKCiAgbG9jYWwgXywgXywgY2xpY2ssIF8sIHdo
ZWVsID0gbW91c2UgKCkKICBpZiBtb3VzZV9vdmVyX3N0YWNrIHRoZW4KICAgIHN0YWNrX3Njcm9s
bCA9IG1hdGgubWF4ICgwLCBtYXRoLm1pbiAoc3RhY2tfc2Nyb2xsIC0gd2hlZWwgKiAyLCBzdGFj
a19tYXhfc2Nyb2xsKSkKICBlbmQKICBzdGFja19zY3JvbGxfc21vb3RoID0gYXBwcm9hY2ggKHN0
YWNrX3Njcm9sbF9zbW9vdGgsIHN0YWNrX3Njcm9sbCkKICBpZiBtb3VzZV9vdmVyX3ZhcmlhYmxl
cyB0aGVuCiAgICB2YXJpYWJsZXNfc2Nyb2xsID0gbWF0aC5tYXggKDAsIG1hdGgubWluICh2YXJp
YWJsZXNfc2Nyb2xsIC0gd2hlZWwgKiAyLCB2YXJpYWJsZXNfbWF4X3Njcm9sbCkpCiAgZW5kCiAg
dmFyaWFibGVzX3Njcm9sbF9zbW9vdGggPSBhcHByb2FjaCAodmFyaWFibGVzX3Njcm9sbF9zbW9v
dGgsIHZhcmlhYmxlc19zY3JvbGwpCgogIGNsaWNrID0gY2xpY2sgfj0gMAogIGlmIGNsaWNrIGFu
ZCBub3QgbW91c2Vfd2FzX2NsaWNrZWQgdGhlbgogICAgaWYgaG92ZXJlZF9zdGFja19pbmRleCB0
aGVuCiAgICAgIGN1cnJlbnRfc3RhY2tfaW5kZXggPSBob3ZlcmVkX3N0YWNrX2luZGV4CiAgICBl
bmQKICAgIGlmIGhvdmVyZWRfdmFyaWFibGUgYW5kIHR5cGUgKGhvdmVyZWRfdmFyaWFibGUudmFs
dWUpID09ICd0YWJsZScgdGhlbgogICAgICBpZiBob3ZlcmVkX3ZhcmlhYmxlLmNvbnRlbnRzIHRo
ZW4KICAgICAgICBob3ZlcmVkX3ZhcmlhYmxlLmNvbnRlbnRzID0gbmlsCiAgICAgIGVsc2UKICAg
ICAgICBsb2NhbCBjb250ZW50cyA9IHt9CiAgICAgICAgaG92ZXJlZF92YXJpYWJsZS5jb250ZW50
cyA9IGNvbnRlbnRzCiAgICAgICAgZm9yIGssdiBpbiBwYWlycyAoaG92ZXJlZF92YXJpYWJsZS52
YWx1ZSkgZG8KICAgICAgICAgIHRhYmxlLmluc2VydCAoY29udGVudHMsIHsKICAgICAgICAgICAg
a2V5ID0gaywKICAgICAgICAgICAgdmFsdWUgPSB2LAogICAgICAgICAgfSkKICAgICAgICBlbmQK
ICAgICAgICBzb3J0IChjb250ZW50cywgY29tcGFyZV9rZXlzKQogICAgICBlbmQKICAgIGVuZAog
IGVuZAogIG1vdXNlX3dhc19jbGlja2VkID0gY2xpY2sKCiAgaWYgY3VycmVudF9zdGFja19pbmRl
eCB_PSBsYXN0X2luZGV4IHRoZW4KICAgIHJlYnVpbGQoKQogIGVuZAplbmQKCmxvY2FsIGZ1bmN0
aW9uIGVycm9yX2RyYXcgKCkKICBsb2NhbCBXID0gZ2V0X2Rpc3BsYXkoKTp3aWR0aCgpCiAgbG9j
YWwgSCA9IGdldF9kaXNwbGF5KCk6aGVpZ2h0KCkKCiAgbG9jYWwgcHJlZml4ID0gdXNlX3NtYWxs
X2ZvbnQgYW5kICdcMDE0JyBvciAnJwogIGxvY2FsIGZvbnRfaGVpZ2h0ID0gKHVzZV9zbWFsbF9m
b250IGFuZCA2IG9yIDExKQogIGxvY2FsIG14LCBteSA9IG1vdXNlKCkKICBsb2NhbCBvdmVyX3Nl
Y3Rpb24gPSBmYWxzZQogIGxvY2FsIHgwLCB5MCwgeCwgeQoKICBsb2NhbCBmdW5jdGlvbiBnb190
byAobmV3X3gsIG5ld195KQogICAgeDAsIHkwID0gbmV3X3gsIG5ld195CiAgICB4LCB5ID0geDAs
IHkwCiAgZW5kCgogIGxvY2FsIGZ1bmN0aW9uIHNlY3Rpb24gKHN4LCBzeSwgc3csIHNoKQogICAg
b3Zlcl9zZWN0aW9uID0KICAgICAgbXggPj0gc3ggYW5kIG14IDwgc3ggKyBzdyBhbmQKICAgICAg
bXkgPj0gc3kgYW5kIG15IDwgc3kgKyBzaAogICAgY2xpcCAoc3gsIHN5LCBzdywgc2gpCiAgICBn
b190byhzeCsyLCBzeSsyKQogIGVuZAoKICBsb2NhbCBmdW5jdGlvbiBwcmludF9ob3Jpem9udGFs
ICh0ZXh0LCBjb2xvcikKICAgIGxvY2FsIG5ld194LCBfbmV3X3kgPSBwcmludCAocHJlZml4IC4u
IHRleHQsIHgsIHksIGNvbG9yKQogICAgeCA9IG5ld194CiAgZW5kCgogIGxvY2FsIGZ1bmN0aW9u
IHByaW50X2xpbmUgKHRleHQsIGNvbG9yKQogICAgbG9jYWwgX25ld194LCBuZXdfeSA9IHByaW50
IChwcmVmaXggLi4gdGV4dCwgeCwgeSwgY29sb3IpCiAgICB4ID0geDAKICAgIHkgPSBuZXdfeQog
IGVuZAoKICAtLSBkcmF3IHNldHVwCiAgY2xzICgwKQogIC0tIGxpZ2h0ZXIgZGFyayBncmF5IGZv
ciByZWFkYWJpbGl0eQogIHBhbCAoNSwgMHhmZjcwNzA3MCwgMikKICBjb2xvciAoNSkKCiAgLS0g
ZXJyb3IgbWVzc2FnZQogIHNlY3Rpb24gKDAsIDAsIFcsIEgvMikKICBtb3VzZV9vdmVyX3N0YWNr
ID0gb3Zlcl9zZWN0aW9uCgogIGxvY2FsIGxvY19wYXRoLCBsb2NfbGluZSwgZXJyID0gcGFyc2Vf
bWVzc2FnZV9mb3JfbG9jYXRpb24gKGVycm9yX21lc3NhZ2UpCiAgaWYgbG9jX3BhdGggdGhlbgog
ICAgcHJpbnRfbGluZSAoJ2Vycm9yIGF0ICcgLi4gbG9jX3BhdGggLi4gJzonIC4uIGxvY19saW5l
IC4uICc6JywgNikKICAgIHByaW50X2xpbmUgKCcgICcgLi4gZXJyLCA4KQogIGVsc2UKICAgIHBy
aW50X2xpbmUgKCdlcnJvcjonLCA2KQogICAgcHJpbnRfbGluZSAoJyAgJyAuLiBlcnJvcl9tZXNz
YWdlLCA4KQogIGVuZAoKICAtLSBzdGFjayBmcmFtZXMKICBwcmludF9saW5lICgnc3RhY2s6Jywg
NikKICBzZWN0aW9uICgwLCB5LCBXLCBILzIteSkKICBsb2NhbCBzdGFja190b3BfeSA9IHkKICB5
ID0geSAtIHJvdW5kIChzdGFja19zY3JvbGxfc21vb3RoICogZm9udF9oZWlnaHQpCiAgbG9jYWwg
bGFzdF9ob3ZlcmVkX3N0YWNrX2luZGV4ID0gaG92ZXJlZF9zdGFja19pbmRleAogIGhvdmVyZWRf
c3RhY2tfaW5kZXggPSBmYWxzZQogIGZvciBpLCBmcmFtZSBpbiBpcGFpcnMgKHN0YWNrX2ZyYW1l
cykgZG8KICAgIGNvbG9yIChsYXN0X2hvdmVyZWRfc3RhY2tfaW5kZXggPT0gaSBhbmQgNyBvcgog
ICAgICAgICAgIGN1cnJlbnRfc3RhY2tfaW5kZXggPT0gaSBhbmQgNiBvciA1KQoKICAgbG9jYWwg
eV9iZWZvcmUgPSB5CiAgICBwcmludF9saW5lIChzdHJpbmcuZm9ybWF0ICgnICAlczolZCBpbiBm
dW5jdGlvbiAlcycsCiAgICAgIGZyYW1lLmZpbGVuYW1lLCBmcmFtZS5saW5lLCBmcmFtZS5mbl9u
YW1lICkpCiAgICBpZiBvdmVyX3NlY3Rpb24gdGhlbgogICAgICBpZiBteSA_PSB5X2JlZm9yZSBh
bmQgbXkgPCB5IHRoZW4KICAgICAgICBob3ZlcmVkX3N0YWNrX2luZGV4ID0gaQogICAgICBlbmQK
ICAgIGVuZAogIGVuZAogIHN0YWNrX21heF9zY3JvbGwgPSAjc3RhY2tfZnJhbWVzIC0gKEgvMiAt
IHN0YWNrX3RvcF95KSAvIGZvbnRfaGVpZ2h0CgogIGxvY2FsIGZyYW1lID0gc3RhY2tfZnJhbWVz
IFtjdXJyZW50X3N0YWNrX2luZGV4XQogIGlmIG5vdCBmcmFtZSB0aGVuCiAgICByZXR1cm4KICBl
bmQKCiAgLS0gdmFyaWFibGVzCiAgc2VjdGlvbiAoMCwgSC8yLCBXLzIsIEgvMikKICBtb3VzZV9v
dmVyX3ZhcmlhYmxlcyA9IG92ZXJfc2VjdGlvbgogIHByaW50X2xpbmUgKCd2YXJpYWJsZXM6Jywg
NikKICBzZWN0aW9uICgwLCB5LCBXLzIsIEgteSkKICBsb2NhbCB2YXJpYWJsZXNfdG9wX3kgPSB5
CiAgeSA9IHkgLSByb3VuZCAodmFyaWFibGVzX3Njcm9sbF9zbW9vdGggKiBmb250X2hlaWdodCkK
ICBsb2NhbCBsYXN0X2hvdmVyZWRfdmFyaWFibGUgPSBob3ZlcmVkX3ZhcmlhYmxlCiAgaG92ZXJl
ZF92YXJpYWJsZSA9IGZhbHNlCiAgbG9jYWwgdmFyaWFibGVfY291bnQgPSAwCiAgbG9jYWwgZnVu
Y3Rpb24gZHJhd192YXJpYWJsZSAodmFyaWFibGUsIGluZGVudCkKICAgIHZhcmlhYmxlX2NvdW50
ID0gdmFyaWFibGVfY291bnQgKyAxCiAgICBsb2NhbCBob3ZlcmVkID0gdmFyaWFibGUgPT0gbGFz
dF9ob3ZlcmVkX3ZhcmlhYmxlCiAgICBsb2NhbCB5X2JlZm9yZSA9IHkKICAgIGlmIHZhcmlhYmxl
LmVycm9yIHRoZW4KICAgICAgcHJpbnRfbGluZSAoJyAgJyAuLiB2YXJpYWJsZS5lcnJvciwgOCkK
ICAgIGVsc2UKICAgICAgcHJpbnRfaG9yaXpvbnRhbCAoaW5kZW50IC4uIHZhcmlhYmxlLmtleSwg
aG92ZXJlZCBhbmQgNyBvciA2KQogICAgICBwcmludF9ob3Jpem9udGFsICgnOiAnLCB2YXJpYWJs
ZSA9PSBsYXN0X2hvdmVyZWRfdmFyaWFibGUgYW5kIDcgb3IgNSkKICAgICAgcHJpbnRfbGluZSAo
c2FmZV90b3N0cmluZyh2YXJpYWJsZS52YWx1ZSkpCiAgICBlbmQKCiAgICBpZiBvdmVyX3NlY3Rp
b24gYW5kIHR5cGUgKHZhcmlhYmxlLnZhbHVlKSA9PSAndGFibGUnIHRoZW4KICAgICAgaWYgbXgg
Pj0gMCBhbmQgbXggPCBXLzIgYW5kIG15ID49IHlfYmVmb3JlIGFuZCBteSA8IHkgdGhlbgogICAg
ICAgIGhvdmVyZWRfdmFyaWFibGUgPSB2YXJpYWJsZQogICAgICBlbmQKICAgIGVuZAoKICAgIGlm
IHZhcmlhYmxlLmNvbnRlbnRzIHRoZW4KICAgICAgZm9yIF8sIHYgaW4gaXBhaXJzICh2YXJpYWJs
ZS5jb250ZW50cykgZG8KICAgICAgICBkcmF3X3ZhcmlhYmxlICh2LCBpbmRlbnQgLi4gJyAgJykK
ICAgICAgZW5kCiAgICBlbmQKICBlbmQKICBmb3IgXywgdmFyaWFibGUgaW4gaXBhaXJzICh2YXJp
YWJsZXMpIGRvCiAgICBkcmF3X3ZhcmlhYmxlICh2YXJpYWJsZSwgJyAgJykKICBlbmQKICB2YXJp
YWJsZXNfbWF4X3Njcm9sbCA9IHZhcmlhYmxlX2NvdW50IC0gKEggLSB2YXJpYWJsZXNfdG9wX3kp
IC8gZm9udF9oZWlnaHQKCiAgLS0gc291cmNlCiAgc2VjdGlvbiAoVy8yLCBILzIsIFcvMiwgSC8y
KQogIHByaW50X2xpbmUgKCdzb3VyY2Ugb2YgJyAuLiBmcmFtZS5wYXRoIC4uICc6JywgNikKICBs
b2NhbCBjb250ZXh0ID0gdXNlX3NtYWxsX2ZvbnQgYW5kIDEwIG9yIDUKICBsb2NhbCBpX21pbiA9
IG1hdGgubWF4ICgxLCBmcmFtZS5saW5lIC0gY29udGV4dCkKICBsb2NhbCBpX21heCA9IG1hdGgu
bWluICgjc291cmNlX2xpbmVzLCBmcmFtZS5saW5lICsgY29udGV4dCkKICBmb3IgaSA9IGlfbWlu
LCBpX21heCBkbwogICAgY29sb3IgKGkgPT0gZnJhbWUubGluZSBhbmQgNiBvciA1KQogICAgcHJp
bnRfaG9yaXpvbnRhbCAoc3RyaW5nLmZvcm1hdCAoJyU0ZCAnLCBpKSkKICAgIHByaW50X2xpbmUg
KHNvdXJjZV9saW5lcyBbaV0pCiAgZW5kCgogIGNsaXAgKCkKZW5kCgotLS0tIHRha2luZyBvdmVy
IGR1cmluZyBlcnJvcnMgLS0tLS0tLS0tLS0tLS0tLS0tLQoKbG9jYWwgZnVuY3Rpb24gcmVzZXQg
KCkKICAtLSBiYXNlZCBvbiByZXNldCgpIGZyb20gL3N5c3RlbS9saWIvaGVhZC5sdWEKICAtLSBz
ZWUgdGhhdCBmbiBmb3IgaW5mbwogIHdpbmRvdyB7CiAgICBjdXJzb3IgPSAxLAogICAgcmVzaXph
YmxlID0gdHJ1ZSwKICB9CiAgbm90ZSAoKQogIC0tIHBpY290cm9uIHNlZ2ZhdWx0cyBpZiB3ZSBj
YWxsIGNsaXAoKSBkdXJpbmcgaW5pdAogIGlmIGluaXRfZG9uZSB0aGVuCiAgICBjbGlwICgpCiAg
ZW5kCiAgY2FtZXJhICgpCiAgcGFsICgpCiAgcGFsdCAoKQogIG1lbXNldCAoMHg1NTFmLCAwLCA5
KQogIHBva2UgKDB4NTUwOCwgMHgzZikKICBwb2tlICgweDU1MDksIDB4M2YpCiAgcG9rZSAoMHg1
NTBhLCAweDNmKQogIHBva2UgKDB4NTUwYiwgMHgwMCkKICBjb2xvciAoNikKICBmaWxscCAoKQog
IHBva2UgKDB4NWY1NiwgMHg0MCkKICBwb2tlICgweDVmNTcsIDB4NTYpCiAgcG9rZSAoMHg0MDAw
LCBnZXQgKGZldGNoIi9zeXN0ZW0vZm9udHMvbGlsLmZvbnQiKSkKICBwb2tlICgweDU2MDAsIGdl
dCAoZmV0Y2giL3N5c3RlbS9mb250cy9wOC5mb250IikpCiAgcG9rZSAoMHg1NjA2LCBwZWVrICgw
eDU2MDApICogNCkKICBwb2tlICgweDU2MDUsIDB4MikKICBwb2tlICgweDVmMjgsIDY0KQogIHBv
a2UgKDB4NWYyOSwgNjQpCmVuZAoKbG9jYWwgZnVuY3Rpb24gb25fZXJyb3IgKHRocmVhZCwgbWVz
c2FnZSkKICAtLSBkbyB0aGlzIGZpcnN0IGluIGNhc2Ugd2UgaGl0IGFub3RoZXIgZXJyb3IKICBl
cnJvcl90cmFjZWJhY2sgPSBkZWJ1Zy50cmFjZWJhY2sgKHRocmVhZCwgbWVzc2FnZSkKICBwcmlu
dGggKGVycm9yX3RyYWNlYmFjaykKCiAgZXJyb3JfdGhyZWFkID0gdGhyZWFkCiAgZXJyb3JfbWVz
c2FnZSA9IHRvc3RyaW5nIChtZXNzYWdlKQogIHJlc2V0ICgpCiAgcmVidWlsZCAoKQogIC0tIGp1
bXAgdG8gdGhlIHByb3BlciBzdGFjayBmcmFtZSBpZiB3ZSBjYW4KICBsb2NhbCBsb2NfcGF0aCwg
bG9jX2xpbmUgPSBwYXJzZV9tZXNzYWdlX2Zvcl9sb2NhdGlvbiAoZXJyb3JfbWVzc2FnZSkKICBm
b3IgaSwgZnJhbWUgaW4gaXBhaXJzIChzdGFja19mcmFtZXMpIGRvCiAgICBpZiBmcmFtZS5wYXRo
ID09IGxvY19wYXRoIGFuZCBmcmFtZS5saW5lID09IGxvY19saW5lIHRoZW4KICAgICAgY3VycmVu
dF9zdGFja19pbmRleCA9IGkKICAgICAgcmVidWlsZCAoKQogICAgICBicmVhawogICAgZW5kCiAg
ZW5kCmVuZAoKLS0tLSBpbnN0YWxsIG1haW4gZXZlbnRzIHRoYXQgY2F0Y2ggZXJyb3JzIC0tLS0t
LS0KCmxvY2FsIHVzZXJfaW5pdCA9IHJhd2dldCAoX0csICdfaW5pdCcpCmxvY2FsIHVzZXJfdXBk
YXRlID0gcmF3Z2V0IChfRywgJ191cGRhdGUnKQpsb2NhbCB1c2VyX2RyYXcgPSByYXdnZXQgKF9H
LCAnX2RyYXcnKQoKYXNzZXJ0ICh1c2VyX2RyYXcgYW5kIHVzZXJfdXBkYXRlLAogICdwbGVhc2Ug
aW5jbHVkZSBlcnJvcl9leHBsb3JlciBhZnRlciBkZWZpbmluZyBib3RoIF91cGRhdGUgYW5kIF9k
cmF3JykKCmlmIG5vdCByYXdnZXQgKF9HLCAnZGVidWcnKSBvciBub3QgZGVidWcudHJhY2ViYWNr
IG9yIG5vdCBkZWJ1Zy5nZXRpbmZvIHRoZW4KICBwcmludGggJ2Vycm9yIGV4cGxvcmVyOiBkZWJ1
ZyBtb2R1bGUgbm90IGF2YWlsYWJsZSwgZXJyb3IgZXhwbG9yZXIgd2lsbCBiZSBkaXNhYmxlZCcK
ICByZXR1cm4KZW5kCgpsb2NhbCBmdW5jdGlvbiBjYWxsX2Vycm9yX2V2ZW50IChmbiwgLi4uKQog
IC0tIGlmIHRoZXJlJ3MgYW4gZXJyb3IgaW4gb3VyIHVwZGF0ZSBvciBkcmF3LCB0aHJvdyB0aGUK
ICAtLSBvcmlnaW5hbCBlcnJvciBhcyB3ZWxsIGFzIHRoZSBuZXcgZXJyb3IKICBsb2NhbCBzdWNj
ZXNzLCBlcnIgPSBwY2FsbCAoZm4sIC4uLikKICBpZiBub3Qgc3VjY2VzcyB0aGVuCiAgICBlcnJv
ciAoZXJyb3JfdHJhY2ViYWNrIC4uICdcblxuZXJyb3IgZHVyaW5nIGVycm9yIGhhbmRsaW5nOiAn
IC4uIHRvc3RyaW5nIChlcnIpKQogIGVuZAplbmQKCmxvY2FsIGZ1bmN0aW9uIGNhbGxfcHJvdGVj
dGVkIChmbikKICAtLSBuZWVkIHRvIHVzZSBjb3Jlc3VtZSBldGMuIGFuZCBub3QgY29yb3V0aW5l
LnJlc3VtZSBldGMuCiAgLS0gZm9yIHBpY290cm9uIGNvbXBhdGliaWxpdHkKICBsb2NhbCB0aHJl
YWQgPSBjb2NyZWF0ZSAoZm4pCiAgbG9jYWwgc3VjY2VzcywgbWVzc2FnZSA9IGNvcmVzdW1lKHRo
cmVhZCkKICB3aGlsZSBjb3N0YXR1cyAodGhyZWFkKSB_PSAnZGVhZCcgZG8KICAgIHlpZWxkICgp
CiAgICBzdWNjZXNzLCBtZXNzYWdlID0gY29yZXN1bWUgKHRocmVhZCkKICBlbmQKICBpZiBub3Qg
c3VjY2VzcyB0aGVuCiAgICBjYWxsX2Vycm9yX2V2ZW50IChvbl9lcnJvciwgdGhyZWFkLCBtZXNz
YWdlKQogIGVuZAplbmQKCmlmIHVzZXJfaW5pdCB0aGVuCiAgZnVuY3Rpb24gX2luaXQgKCkKICAg
IGNhbGxfcHJvdGVjdGVkICh1c2VyX2luaXQpCiAgICBpbml0X2RvbmUgPSB0cnVlCiAgZW5kCmVs
c2UKICBpbml0X2RvbmUgPSB0cnVlCmVuZAoKZnVuY3Rpb24gX3VwZGF0ZSAoKQogIGlmIGVycm9y
X3RocmVhZCB0aGVuCiAgICBjYWxsX2Vycm9yX2V2ZW50IChlcnJvcl91cGRhdGUpCiAgZWxzZQog
ICAgY2FsbF9wcm90ZWN0ZWQgKHVzZXJfdXBkYXRlKQogIGVuZAplbmQKCmZ1bmN0aW9uIF9kcmF3
ICgpCiAgaWYgZXJyb3JfdGhyZWFkIHRoZW4KICAgIGNhbGxfZXJyb3JfZXZlbnQgKGVycm9yX2Ry
YXcpCiAgZWxzZQogICAgY2FsbF9wcm90ZWN0ZWQgKHVzZXJfZHJhdykKICBlbmQKZW5k
:: field.lua
--[[pod_format="raw",created="2025-06-18 13:14:24",modified="2025-06-27 14:29:25",revision=1865]]
function new_field()
	return {
		position = new_point(200, 100),
		width = 6,
		total_height = 10,   -- full cup height
		visible_rows = 5,    -- number of visible matchable rows
		preview_rows = 1,    -- preview row count
		cup = {},

		init = function(self)
			for i = 1, self.width do
				local col = {}
				for j = 1, self.total_height do
					local b = pick_random(bead_bank)(self.position, new_point(i, j))
					b:init()
					add(col, b)
				end
				add(self.cup, col)
			end
		end,

		visible_start = function(self)
			return self.total_height - self.visible_rows - self.preview_rows + 1
		end,

		match_start = function(self)
			return self.total_height - self.visible_rows + 1
		end,

		update = function(self)
			local ret=false
			for i = 1, self.width do
				for j = 1, self.total_height do
					local bead=self.cup[i][j]
					if(bead!=nil) then
						if(bead:update()) then 
							ret=true
						end							
					end
				end
			end
			return ret
		end,

		draw = function(self)
			local y0 = self:visible_start()
			local y1 = self.total_height
			for i = 1, self.width do
				for j = y0, y1 do
					local bead=self.cup[i][j]
					if(bead!=nil) then
						bead:draw()
					end
				end
			end

			local width = 5
			local color = 19
			local px = self.position.x
			local py = self.position.y + (y0 - 1) * tileSize
			local gw = self.width * tileSize
			local gh = (y1 - y0 + 1) * tileSize

			rectfill(px - width, py - width, px, py + gh, color)               -- left wall
			rectfill(px + gw, py - width, px + gw + width, py + gh, color)     -- right wall
			rectfill(px - width, py + gh, px + gw + width, py + gh + width, color) -- bottom wall
			rectfill(px - width, py - width-tileSize, px + gw + width, py+halfTileSize, color)       -- top wall
		end,
		swap = function(self, pos1, pos2)
			-- Get beads
			local bead1 = self.cup[pos1.x][pos1.y]
			local bead2 = self.cup[pos2.x][pos2.y]
		
			-- Swap them in the grid
			self.cup[pos1.x][pos1.y] = bead2
			self.cup[pos2.x][pos2.y] = bead1
		
			-- Update their internal position fields
			if bead1 then
				bead1.position.x = pos2.x
				bead1.position.y = pos2.y
				
				--bead1.visual_position=bead1.position:clone()
				
			end
		
			if bead2 then
				bead2.position.x = pos1.x
				bead2.position.y = pos1.y
				--bead2.visual_position=bead2.position:clone()
			end
		end,
		find_matches = function(self)
			local matches={}
			local y_start = self:match_start()
			local y_end = self.total_height
			-- horizontal
			if(game.stats.match_horizontal) then
				for y = y_start, y_end do
					local run_type = self.cup[1][y].color
					local run_start = 1
					local run_len = 1
	
					for x = 2, self.width + 1 do
						local next_type = (x <= self.width) and self.cup[x][y].color or nil
						if next_type == run_type then
							run_len += 1
						else
							if run_len >= 3 then
								for i = run_start, run_start + run_len - 1 do
									add(matches,self.cup[i][y])
									self.cup[i][y].matched = true
								end
							end
							run_type = next_type
							run_start = x
							run_len = 1
						end
					end
				end
			end
			-- vertical
			if(game.stats.match_vertical) then
				for x = 1, self.width do
					local run_type = self.cup[x][self:match_start()].color
					local run_start = self:match_start()
					local run_len = 1
	
					for y = self:match_start() + 1, self.total_height + 1 do
						local next_type = (y <= self.total_height) and self.cup[x][y].color or nil
						if next_type == run_type then
							run_len += 1
						else
							if run_len >= 3 then
								for i = run_start, run_start + run_len - 1 do
									add(matches,self.cup[x][i])
									self.cup[x][i].matched = true
								end
							end
							run_type = next_type
							run_start = y
							run_len = 1
						end
					end
				end
			end
			--square
			if(game.stats.match_square) then
				for x = 1, self.width - 1 do
					for y = self:match_start(), self.total_height - 1 do
						local a = self.cup[x][y]
						local b = self.cup[x + 1][y]
						local c = self.cup[x][y + 1]
						local d = self.cup[x + 1][y + 1]
				
						if a and b and c and d and
						   a.color == b.color and
						   a.color == c.color and
						   a.color == d.color then
				
							local square = {a, b, c, d}
							for _, bead in ipairs(square) do
								if not bead.matched then
									add(matches, bead)
									bead.matched = true
								end
							end
						end
					end
				end
			end
			return matches
		end,

		remove_matched = function(self)
			for x = 1, self.width do
				local write_y = self.total_height

				for y = self.total_height, 1, -1 do
					local bead = self.cup[x][y]
					if bead and not bead.matched then
						if write_y ~= y then
							self.cup[x][write_y] = bead
							self.cup[x][y] = nil
							bead.position.x = x
							bead.position.y = write_y
						end
						write_y -= 1
					else
						self.cup[x][y] = nil
					end
				end

				for y = write_y, 1, -1 do
					local b = pick_random(bead_bank)(self.position, new_point(x, y))
					b:init()
					b.visual_position.y = y-- - self.total_height
					self.cup[x][y] = b
				end
			end
		end
	}
end

:: game.lua
--[[pod_format="raw",created="2025-06-18 12:49:39",modified="2025-07-01 20:50:59",revision=2450]]

function new_game()
	return{
		field=nil,
		state=0, 
		cursor=nil,
		god_cursor=nil, 
		goal=100,
		points=0,
		points_hint="",
		multiplier=1,
		moves=0,		
		movetimer=0,
		stats=nil,
		shop=nil,
		current_trial=1,
		current_trial_sprite=0,		
		week_sprite=129,
		
	
		week=get_week(),	
		setup_trial = function(self,trial)
			self.goal=trial.point_goal
			self.current_trial_sprite=trial.sprite
		end,
		init=function(self)
			self:setup_trial(self.week.trials[self.current_trial])	
	
			self.field=new_field()
			self.field:init()
			self.stats=new_stats()
			self.stats:init()
			
			self.shop=new_shop(self.stats)
			--add(self.stats.gods,malvex_god(self.stats))

--			for i=1,#god_ctors do
--				local god=god_ctors[i](self.stats) 
--				god:init()
--				add(self.stats.gods,god)
--			end
			
			self.stats:update_stats()
			self.cursor=new_cursor(self.field.position,new_point(3,7))
			self.cursor:init()
			self.god_cursor=new_god_cursor(self.stats)
			self.god_cursor:init()

		end,
		update=function(self)
			if(self.state!=5) then
				self.cursor:update()
			else
				self.god_cursor:update()
			end				
			--0=free 1=moving 2=check 3=remove 4=drop 5=menu
			if(self.state==0 and self.stats.points>=self.goal) then
				self.stats:add_message("You win this day",colors.yellow )
				self.state=6
				self.shop:init()
				self.stats:add_message("This trial grants "..self.week.trials[self.current_trial].reward.." boons",colors.yellow )
				self.stats.coins+=self.week.trials[self.current_trial].reward
				local remaining_moves=self.stats.moves_max-self.moves
				if(remaining_moves>0)then
					self.stats.coins+=remaining_moves
					self.stats:add_message("Remaining time grants "..remaining_moves.." boons",colors.yellow )
				end			
				self.moves=0
				
				local extra=flr(self.stats.points/self.goal)-1
				if(extra>0)then
					self.stats.coins+=extra
					self.stats:add_message("Your zeal adds "..extra.." boons",colors.yellow )
				end		
			elseif(self.state==0 and self.moves>=self.stats.moves_max) then --out of turns

				self.stats.lives-=1
				if(self.stats.lives>0) then
					self.stats:add_message("You have been granted another chance",colors.yellow )
					self.moves=0
					self.stats:reset_trial()
				else
					self.stats:add_message("You have failed. Your soul is lost",colors.red )
					self.state=999
				end
			elseif(self.state==0 ) then --wait for player to make a move
				if(input:button_press(input_lookup.buttons.o)) then
					self.state=1
					self.moves+=1
					self.movetimer=self.stats.movetimer_max
				elseif(#self.stats.gods>1 and  input:button_press(input_lookup.buttons.x)) then
					self.state=5
					self.stats.selected_god=2
				end		
			elseif (self.state==1) then --wait for player to finish a move
				if(input:button_press(input_lookup.buttons.o)or self.movetimer<=0) then
					self.state=2
					self.movetimer=0
				else
					self.field:update()
					self.movetimer-=1
				end
			elseif (self.state==2) then --do matches
				if(self.field:update()==false) then
					local matches=self.field:find_matches()
					if(#matches>0) then
						self.state=3
						self.stats:score_matches(matches)
					else
						self.stats:score_matches(matches)
						self.state=0
						self.stats:reset_chain()
						
					end
				end
			elseif (self.state==3) then --clean up matches
				if(self.field:update()==false) then
					self.state=4
					self.field:remove_matched()
				end	
			elseif (self.state==4) then --if more matches, keep going
				if(self.field:update()==false) then
					self.state=2
				end
			elseif(self.state==5) then --god viewer is open
				if(input:button_press(input_lookup.buttons.x) or input:button_press(input_lookup.buttons.o)) then
					self.state=0
					self.stats.selected_god=0
				end
			elseif(self.state==6) then --open the shop
				self.shop:update()		
			end	
			
		end,
		draw=function(self)
			cls(5)
			self.field:draw()
			self.cursor:draw()
			--print_centered("points:"..self.stats.points,10,7)
			for i=#self.stats.messages,1,-1 do
				local message=self.stats.messages[i]
				print_centered(message.text,20+(8*(#self.stats.messages-i)),message.color)				
			end
			
			--print_centered("moves left:"..self.moves,130,7)
			print(self.movetimer.."/"..self.stats.movetimer_max,200,145,7)	
			draw_fill_bar_h(new_point(200, 155),
								new_point(95,10),self.movetimer,self.stats.movetimer_max,7,7)
			print(self.stats.moves_max-self.moves.."/"..self.stats.moves_max,175,156)					
			draw_fill_bar_v(new_point(180, 166),
					new_point(10,95),self.stats.moves_max-self.moves,self.stats.moves_max,7,7)
			print(self.stats.points.."/"..self.goal,306,156)
			draw_fill_bar_v(new_point(306, 166),
					new_point(10,95),self.stats.points,self.goal,7,7)
			--day of week	
			spr(self.current_trial_sprite,200,2)
			
			spr(self.week_sprite,352,2)
			self.stats:draw()
			self.god_cursor:draw()
			
			spr(130,140,2)
			print(self.stats.coins, 140+16,8,7)
		
			if(self.state==6) then --open the shop
				self.shop:draw()		
			end
		end,	
		next_level=function(self)
				self.current_trial+=1
				local next_trial=self.week.trials[self.current_trial]
				if(next_trial!=nil) then
					self:setup_trial(next_trial)
					self.stats:reset_trial()
					self.state=0
				else
					self.stats:add_message("You completed the week",colors.yellow )
					self.current_trial=1
				end
		end
	}
end

:: god.lua
--[[pod_format="raw",created="2025-06-21 17:03:03",modified="2025-06-21 17:38:34",revision=37]]
new_god=function(stats)
	return {
		name,
		title,
		sprite,
		description,
		stats=stats,
		update_color_values=function(self) end,
		update_combo_values=function(self) end,
		update_chain_values=function(self) end,
		reset_chain=function(self) end,
		score_matches=function(self,matches) end,
		update=function(self)
			self:update_color_values()
			self:update_combo_values()
			self:update_chain_values()
		end
	}
end

new_base_god=function(stats)
	ret= new_god(stats)
	ret.chait_total=0
	ret.score_matches=function(self,matches)
		local combo_value=self.stats.combo_values[#matches-2]
		--get average value	
		local tile_value_sum=0
		for _,color in  ipairs(matches) do			
			tile_value_sum+=self.stats.color_values[color]
		end	
		local average=tile_value_sum/#matches
		local points=flr(average*combo_value+.5)--round to nearest point
		local chain_mult=self.stats.chain_values[self.stats.chain_counter]	
		local chain_points= points*chain_mult
		self.stats.points+=chain_points
		self.stats.chain_counter+=1 
		self.stats:add_message("you:"average.."x"..combo_value.."x"..chain_mult.."="..chain_points)
		self.chait_total+=chain_points
	end
	ret.reset_chain=function(self)
		self.stats.chain_counter=1
		self.stats:add_message("chain total:"..self.chait_total,colors.white)
		self.chait_total=0
	end
	ret.update_color_values= function(self) --set values of all colors to 1
		for i = 1,5 do
			add(self.stats.color_values,1)
		end
	end
	ret.update_combo_values= function(self) --set values of all combos to n
		for i = 1,27 do --the first combo is 3
			add(self.stats.combo_values,i)
		end
	end
	ret.update_chain_values= function(self) --set values of all combos to n
		for i = 1,20 do 
			add(self.stats.chain_values,i)
		end
	end
	return ret
end

:: god_cursor.lua
--[[pod_format="raw",created="2025-06-23 12:58:19",modified="2025-07-01 18:04:12",revision=324]]
function new_god_cursor(stats)
	return{
		stats=stats,
		init=function(self)			
		end,
		update=function(self)
			if(self.stats.selected_god!=0) then
				local id =self.stats.selected_god-2
				if input:button_press(input_lookup.lpad.left) then 
					id-=1				
				elseif input:button_press(input_lookup.lpad.right) then 
					id+=1
				elseif input:button_press(input_lookup.lpad.up) then 
					id-=3
				elseif input:button_press(input_lookup.lpad.down) then 
					id+=3
				end
				if((id+1)>0 and (id+1)<#self.stats.gods) then
					self.stats.selected_god=id+2
				end
			end
			
		end,
		draw=function(self)
			if(self.stats.selected_god!=0) then
				local id =self.stats.selected_god-2
				local i = flr(id/3)
				local j = id%3
				local offset=new_point(2+(j)*46,(i)*52+2)
				rect(offset.x,offset.y,offset.x+42,offset.y+48,7)				
			end
		end
	}
end
:: helpers.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNS0wNi0xOCAxMjo1NTozNyIsbW9k
aWZpZWQ9IjIwMjUtMDYtMjcgMTQ6Mjk6MjUiLHJldmlzaW9uPTE2NjBdXQpmdW5jdGlvbiBzbShh
KQoJcmV0dXJuIHNldG1ldGF0YWJsZShhLGEpCmVuZApmdW5jdGlvbiByYW5kb20obikKCWlmKG4_
MCkgdGhlbiAKCQlyZXR1cm4gcm5kKCkqbgoJZWxzZQoJCXJldHVybiAtbitybmQoKSpuKjIgCgll
bmQKZW5kCmZ1bmN0aW9uIHBpY2tfcmFuZG9tKGFycikKCWlmIGFycj09bmlsbCB0aGVuIHJldHVy
biBuaWwgZW5kCglpZiAjYXJyID09IDAgdGhlbiByZXR1cm4gbmlsIGVuZAoJcmV0dXJuIGFycltm
bHIocm5kKCNhcnIpKSArIDFdCmVuZApmdW5jdGlvbiBibG9ja19jb2xsaXNpb24ocG9pbnRBLCBz
aXplQSwgcG9pbnRCLCBzaXplQikKCWxvY2FsIGF4MSwgYXkxID0gcG9pbnRBLngsIHBvaW50QS55
Cglsb2NhbCBheDIsIGF5MiA9IGF4MSArIHNpemVBLngsIGF5MSArIHNpemVBLnkKCglsb2NhbCBi
eDEsIGJ5MSA9IHBvaW50Qi54LCBwb2ludEIueQoJbG9jYWwgYngyLCBieTIgPSBieDEgKyBzaXpl
Qi54LCBieTEgKyBzaXplQi55CgoJaWYgYXgxIDwgYngyIGFuZCBheDIgPiBieDEgYW5kIGF5MSA8
IGJ5MiBhbmQgYXkyID4gYnkxIHRoZW4KCQlyZXR1cm4gcG9pbnRBLXBvaW50QgoJZW5kCgoJcmV0
dXJuIG5pbAplbmQKZnVuY3Rpb24gY2FyZGluYWxfZGlyZWN0aW9uKHYsIHRocmVzaG9sZCkKCXRo
cmVzaG9sZCA9IHRocmVzaG9sZCBvciAxICAtLSBtaW5pbXVtIGRpZmZlcmVuY2UgYmV0d2VlbiBh
eGVzCgoJbG9jYWwgYWJzX3ggPSBhYnModi54KQoJbG9jYWwgYWJzX3kgPSBhYnModi55KQoJaWYg
YWJzX3ggPiBhYnNfeSArIHRocmVzaG9sZCB0aGVuCgkJcmV0dXJuIG5ld19wb2ludChzaWduKHYu
eCksIDApCgllbHNlaWYgYWJzX3kgPiBhYnNfeCArIHRocmVzaG9sZCB0aGVuCgkJcmV0dXJuIG5l
d19wb2ludCgwLCBzaWduKHYueSkpCgllbHNlCgkJcmV0dXJuIG5pbCAgLS0gdG9vIGRpYWdvbmFs
LCBkb24ndCBhdHRhY2gKCWVuZAplbmQKZnVuY3Rpb24gc2lnbihuKQoJaWYgbiA_IDAgdGhlbiBy
ZXR1cm4gMQoJZWxzZWlmIG4gPCAwIHRoZW4gcmV0dXJuIC0xCgllbHNlIHJldHVybiAwCgllbmQK
ZW5kCmZ1bmN0aW9uIGdldF9zdHJpbmdfd2lkdGgocykKCWxvY2FsIHdpZHRoPXByaW50KHMsLTEw
MDAsMCkKCXByaW50KCIiLDAsMCkKCXJldHVybiB3aWR0aCsxMDAwCmVuZApmdW5jdGlvbiBwcmlu
dF9jZW50ZXJlZCh0ZXh0LCB5LCBjb2wpCgljb2wgPSBjb2wgb3IgY29sb3JzLndoaXRlCglsb2Nh
bCB0ZXh0X3dpZHRoID1nZXRfc3RyaW5nX3dpZHRoKHRleHQpCglsb2NhbCB4ID0gKHNjcmVlbldp
ZHRoIC0gdGV4dF93aWR0aCkgXCAyCglwcmludCh0ZXh0LHgrY2FtZXJhX2hlbHBlcjpnZXRfY2Ft
ZXJhKCkueCwgeStjYW1lcmFfaGVscGVyOmdldF9jYW1lcmEoKS55LCBjb2wpCmVuZApmdW5jdGlv
biBwcmludF9yaWdodCh0ZXh0LCB5LCBjb2wpCgljb2wgPSBjb2wgb3IgIGNvbG9ycy53aGl0ZQoJ
bG9jYWwgdGV4dF93aWR0aCA9Z2V0X3N0cmluZ193aWR0aCh0ZXh0KQoJbG9jYWwgeCA9IHNjcmVl
bldpZHRoIC0gdGV4dF93aWR0aAoJcHJpbnQodGV4dCwgeCtjYW1lcmFfaGVscGVyOmdldF9jYW1l
cmEoKS54LCB5LCBjb2wpCmVuZApmdW5jdGlvbiBwcmludF93cmFwcGVkKHRleHQsIHBvc2l0aW9u
LCB3aWR0aCwgY29sb3IpCglsb2NhbCB3b3JkcyA9IHt9Cglmb3Igd29yZCBpbiBhbGwoc3BsaXQo
dGV4dCwgIiAiLCBmYWxzZSkpIGRvCgkJYWRkKHdvcmRzLCB0b3N0cmluZyh3b3JkKSkKCWVuZAoK
CWxvY2FsIHggPSBwb3NpdGlvbi54Cglsb2NhbCB5ID0gcG9zaXRpb24ueQoJbG9jYWwgbGluZSA9
ICIiCglsb2NhbCBsaW5lX2hlaWdodCA9IDggIC0tIGZvbnQgbGluZSBoZWlnaHQKCglmb3IgaSwg
d29yZCBpbiBpcGFpcnMod29yZHMpIGRvCgkJbG9jYWwgdGVzdF9saW5lID0gKCNsaW5lID4gMCkg
YW5kIChsaW5lIC4uICIgIiAuLiB3b3JkKSBvciB3b3JkCgkJaWYgZ2V0X3N0cmluZ193aWR0aCh0
ZXN0X2xpbmUpID4gd2lkdGggdGhlbgoJCQlwcmludChsaW5lLCB4LCB5LCBjb2xvcikKCQkJeSAr
PSBsaW5lX2hlaWdodAoJCQlsaW5lID0gd29yZAoJCWVsc2UKCQkJbGluZSA9IHRlc3RfbGluZQoJ
CWVuZAoJZW5kCgoJaWYgI2xpbmUgPiAwIHRoZW4KCQlwcmludChsaW5lLCB4LCB5LCBjb2xvcikK
CQl5ICs9IGxpbmVfaGVpZ2h0CgllbmQKCglyZXR1cm4geSAtIHBvc2l0aW9uLnkKZW5kCmZ1bmN0
aW9uIHBhZF9udW1iZXIobiwgd2lkdGgsY2hhcikKCWNoYXI9Y2hhciBvciAiICIKCWxvY2FsIHMg
PSB0b3N0cmluZyhuKQoJd2hpbGUgI3MgPCB3aWR0aCBkbwoJCXMgPSBjaGFyIC4uIHMKCWVuZAoJ
cmV0dXJuIHMKZW5kCmZ1bmN0aW9uIGlzX3BvaW50X29uX3NjcmVlbihwb2ludCkKCQoJbG9jYWwg
Y2FtZXJhX3Bvcz1jYW1lcmFfaGVscGVyOmdldF9jYW1lcmEoKQoJCglyZXR1cm4gKAoJCXBvaW50
LnggPj0gY2FtZXJhX3Bvcy54IC0gdGlsZVNpemUgYW5kIHBvaW50LnggPCBjYW1lcmFfcG9zLngg
KyBzY3JlZW5XaWR0aCBhbmQKCQlwb2ludC55ID49IGNhbWVyYV9wb3MueSAtIHRpbGVTaXplIGFu
ZCBwb2ludC55IDwgY2FtZXJhX3Bvcy55ICsgc2NyZWVuSGVpZ2h0CgkpCmVuZApjb2xvcnMgPSB7
CglibGFjayAgICAgICAgPSAwLAoJZGFya19ibHVlICAgID0gMSwKCWRhcmtfcHVycGxlICA9IDIs
CglkYXJrX2dyZWVuICAgPSAzLAoJYnJvd24gICAgICAgID0gNCwKCWRhcmtfZ3JheSAgICA9IDUs
CglsaWdodF9ncmF5ICAgPSA2LAoJd2hpdGUgICAgICAgID0gNywKCXJlZCAgICAgICAgICA9IDgs
CglvcmFuZ2UgICAgICAgPSA5LAoJeWVsbG93ICAgICAgID0gMTAsCglncmVlbiAgICAgICAgPSAx
MSwKCWJsdWUgICAgICAgICA9IDEyLAoJaW5kaWdvICAgICAgID0gMTMsCglwaW5rICAgICAgICAg
PSAxNCwKCXBlYWNoICAgICAgICA9IDE1LAoKCS0tIEV4dGVuZGVkIGNvbG9ycyAoMTbigJM2Mykg
bWF5IHZhcnkgYnkgcGFsZXR0ZSBzZXR1cCwgYnV0IGhlcmUncyBhIHVzZWZ1bCBkZWZhdWx0IHNl
dDoKCXJvc2UgICAgICAgICA9IDE2LAoJc2FsbW9uICAgICAgID0gMTcsCgliZWlnZSAgICAgICAg
PSAxOCwKCWxpZ2h0X3llbGxvdyA9IDE5LAoJbGlnaHRfZ3JlZW4gID0gMjAsCglzZWFmb2FtICAg
ICAgPSAyMSwKCXNreV9ibHVlICAgICA9IDIyLAoJcGVyaXdpbmtsZSAgID0gMjMsCglsYXZlbmRl
ciAgICAgPSAyNCwKCWxpZ2h0X3BpbmsgICA9IDI1LAoJZGFya19icm93biA9MjgsCglwdXJwbGU9
MzAKCS0tIC4uLnlvdSBjYW4gY29udGludWUgYWRkaW5nIGFzIG5lZWRlZAp9Cm5ld190aW1lcj1m
dW5jdGlvbihzcGF3bl9yYXRlLHN0YXJ0LGFjdGlvbikKCXJldHVybnsKCXNwYXduX3JhdGU9c3Bh
d25fcmF0ZSwKCXRpbWVyPXN0YXJ0LAoJYWN0aW9uPWFjdGlvbiwKCXVwZGF0ZT1mdW5jdGlvbihz
ZWxmLG90aGVyKQoJCWlmKAlzZWxmLmFjdGlvbj09bmlsKSB0aGVuCgkJCXJldHVybgoJCWVuZAoK
CQlpZihzZWxmLnNwYXduX3JhdGU9PTApIHRoZW4KCQkJcmV0dXJuCgkJZWxzZWlmKHNlbGYuc3Bh
d25fcmF0ZT4xKQl0aGVuCQoJCQlpZihzZWxmLnRpbWVyPnNlbGYuc3Bhd25fcmF0ZSkgdGhlbgoJ
CQkJc2VsZi5hY3Rpb24ob3RoZXIpCgkJCQlzZWxmLnRpbWVyPTAKCQkJZWxzZQoJCQkJc2VsZi50
aW1lcis9MQoJCQllbmQKCQllbHNlCgkJCWZvciBpPTEsMS9zZWxmLnNwYXduX3JhdGUsMSBkbwoJ
CQkJc2VsZi5hY3Rpb24ob3RoZXIpCgkJCWVuZAoJCWVuZAoJZW5kCgl9CmVuZAoKZnVuY3Rpb24g
cmFuZG9tX29mZnNjcmVlbl9wb2ludCgpCglsb2NhbCBzaWRlID0gZmxyKHJuZCg0KSkgIC0tIHBp
Y2sgYSByYW5kb20gc2lkZTogMD10b3AsIDE9Ym90dG9tLCAyPWxlZnQsIDM9cmlnaHQKCWlmIHNp
ZGUgPT0gMCB0aGVuCgkJLS0gVG9wOiB5ID0gLXRpbGVTaXplCgkJcmV0dXJuIG5ld19wb2ludChm
bHIocm5kKHNjcmVlbldpZHRoIC8gdGlsZVNpemUpKSAqIHRpbGVTaXplLCAtdGlsZVNpemUpCgll
bHNlaWYgc2lkZSA9PSAxIHRoZW4KCQktLSBCb3R0b206IHkgPSBzY3JlZW5IZWlnaHQKCQlyZXR1
cm4gbmV3X3BvaW50KGZscihybmQoc2NyZWVuV2lkdGggLyB0aWxlU2l6ZSkpICogdGlsZVNpemUs
IHNjcmVlbkhlaWdodCkKCWVsc2VpZiBzaWRlID09IDIgdGhlbgoJCS0tIExlZnQ6IHggPSAtdGls
ZVNpemUKCQlyZXR1cm4gbmV3X3BvaW50KC10aWxlU2l6ZSwgZmxyKHJuZChzY3JlZW5IZWlnaHQg
LyB0aWxlU2l6ZSkpICogdGlsZVNpemUpCgllbHNlCgkJLS0gUmlnaHQ6IHggPSBzY3JlZW5XaWR0
aAoJCXJldHVybiBuZXdfcG9pbnQoc2NyZWVuV2lkdGgsIGZscihybmQoc2NyZWVuSGVpZ2h0IC8g
dGlsZVNpemUpKSAqIHRpbGVTaXplKQoJZW5kCmVuZApmdW5jdGlvbiByYW5kb21fb25zY3JlZW5f
cG9pbnQoKQoJbG9jYWwgeCA9IGZscihybmQoc2NyZWVuV2lkdGgpKSAKCWxvY2FsIHkgPSBmbHIo
cm5kKHNjcmVlbkhlaWdodCkpCglyZXR1cm4gbmV3X3BvaW50KHgsIHkpCmVuZAoKZnVuY3Rpb24g
Z2V0X2ZyYW1lKGFycixzcGVlZCkJCglyZXR1cm4gYXJyWyhmbHIodCgpKjYwLyhzcGVlZCBvciAx
KSklI2FycisxKV0KZW5kCgpmdW5jdGlvbiBkcmF3X2ZpbGxfYmFyX2godXBwZXJfbGVmdCxzaXpl
LGZpbGwsbWF4LGJvcmRlcl9jb2xvcixmaWxsX2NvbG9yKQoJbG9jYWwgbG93ZXJfcmlnaHQ9dXBw
ZXJfbGVmdCtzaXplCglyZWN0ZmlsbCh1cHBlcl9sZWZ0LngsdXBwZXJfbGVmdC55LAoJCXVwcGVy
X2xlZnQueCtzaXplLngqIG1pbiggKGZpbGwgLyBtYXgpLDEpLAlsb3dlcl9yaWdodC55CgkJLGZp
bGxfY29sb3IpCglyZWN0KHVwcGVyX2xlZnQueCx1cHBlcl9sZWZ0LnksbG93ZXJfcmlnaHQueCxs
b3dlcl9yaWdodC55LGJvcmRlcl9jb2xvcikKZW5kCgpmdW5jdGlvbiBkcmF3X2ZpbGxfYmFyX3Yo
dXBwZXJfbGVmdCwgc2l6ZSwgZmlsbCwgbWF4LCBib3JkZXJfY29sb3IsIGZpbGxfY29sb3IpCgls
b2NhbCBsb3dlcl9yaWdodCA9IHVwcGVyX2xlZnQgKyBzaXplCglsb2NhbCBmaWxsX2hlaWdodCA9
IHNpemUueSAqIG1pbiggKGZpbGwgLyBtYXgpLDEpCQoJLS0gRHJhdyBmaWxsZWQgcG9ydGlvbiBm
cm9tIHRvcCBkb3dud2FyZAoJcmVjdGZpbGwoCgkJdXBwZXJfbGVmdC54LAoJCWxvd2VyX3JpZ2h0
LnkgLSBmaWxsX2hlaWdodCwKCQlsb3dlcl9yaWdodC54LAoJCWxvd2VyX3JpZ2h0LnksCgkJZmls
bF9jb2xvcgoJKQoKCS0tIERyYXcgYm9yZGVyCglyZWN0KAoJCXVwcGVyX2xlZnQueCwKCQl1cHBl
cl9sZWZ0LnksCgkJbG93ZXJfcmlnaHQueCwKCQlsb3dlcl9yaWdodC55LAoJCWJvcmRlcl9jb2xv
cgoJKQplbmQ=
:: include.lua
--[[pod_format="raw",created="2025-06-18 12:41:36",modified="2025-07-01 18:04:12",revision=1886]]
include "lib.lua"
include "helpers.lua"
include "point.lua"
include "sfx.lua"
include "ui.lua"
include "particle_system.lua"
include "camera.lua"
include "input.lua"
include "game.lua"

include "stats.lua"
include "field.lua"
include "bead.lua"
include "cursor.lua"
include "god_cursor.lua"
include "stats.lua"
include "level.lua"

include "shop.lua"
include "shop_cursor.lua"

include "gods/god.lua"
include "gods/red_gods.lua"
include "gods/green_gods.lua"
include "gods/blue_gods.lua"
include "gods/purple_gods.lua"
include "gods/yellow_gods.lua"
:: input.lua
--[[pod_format="raw",created="2025-06-19 02:47:43",modified="2025-06-25 20:21:36",revision=696]]
input_lookup = {
	-- Define logical mappings for clarity
	lpad = {
		left = 0,
		right = 1,
		up = 2,
		down = 3
	},
	rpad = {
		left = 8,
		right = 9,
		up = 10,
		down = 11
	},
	buttons = {
		o = 4,
		x = 5,
		menu=6,
		a = 12,
		b = 13
	}
}
function new_input(player)
	return {
	player=player or 0,
	_button_down_frame = {},
button=function(self, b, hold)
	local now = t()
	if type(b) ~= "table" then
		b = {b}
	end
	local key = join_with_dashes(b)

	if all_buttons_pressed(b, self.player) then
		local start = self._button_down_frame[key]
		if not start then
			self._button_down_frame[key] = now
			return 1  -- just pressed
		end

		local held = now - start 

		if hold then
			if held >= hold then
				if held >= hold + 0.1 then  -- small extra time past charge (you can adjust)
					return 4  -- overheld
				else
					return 3  -- finished charging
				end
			else
				return 2  -- still holding
			end
		else
			return held  -- legacy: how long held (seconds)
		end
	else
		self._button_down_frame[key] = nil
		return nil
	end
end,
		button_press=function(self,b)
			return btnp(b,self.player)
		end
	}
end
function join_with_dashes(arr)
	local result = ""
	for i = 1, #arr do
		result ..= arr[i]
		if i < #arr then
			result ..= "-"
		end
	end
	return result
end
function all_buttons_pressed(buttons, player)
	player = player or 0  -- default to player 0 if not specified
	for i = 1, #buttons do
		if not btn(buttons[i], player) then
			return false
		end
	end
	return true
end
:: level.lua
--[[pod_format="raw",created="2025-06-25 20:26:34",modified="2025-07-01 20:50:59",revision=198]]
function get_week()
	local ret= new_week()
	ret.sprite=129
	--add(ret.trials,new_trial(128,20,2))
	add(ret.trials,new_trial(128,10,2))
	add(ret.trials,new_trial(136,20,2))
	add(ret.trials,new_trial(144,50,2))
	add(ret.trials,new_trial(152,100,2))
	add(ret.trials,new_trial(160,200,2))
	return ret
end

new_week=function()
	return{
		sprite=0,
		trials={}
	}
end

new_trial=function(sprite,point_goal,reward)
	return{
		sprite=sprite or 0,
		point_goal= point_goal or 0,
		reward=reward or 0
	}
end
:: lib.lua
--[[pod_format="raw",created="2025-06-18 12:48:35",modified="2025-06-18 20:24:52",revision=450]]
--lib

-- pq-debugging, by pancelor

-- quotes all args and prints to host console
-- usage:
--   pq("handles nils", many_vars, {tables=1, work=11, too=111})
function pq(...)
  printh(qq(...))
  return ...
end

-- quotes all arguments into a string
-- usage:
--   ?qq("p.x=",x,"p.y=",y)
function qq(...)
  local args=pack(...)
  local s=""
  for i=1,args.n do
    s..=quote(args[i]).." "
  end
  return s
end

-- quote a single thing
-- like tostr() but for tables
-- don't call this directly; call pq or qq instead
function quote(t, depth)
  depth=depth or 4 --avoid inf loop
  if type(t)~="table" or depth<=0 then return tostr(t) end

  local s="{"
  for k,v in pairs(t) do
    s..=tostr(k).."="..quote(v,depth-1)..","
  end
  return s.."}"
end

-- like sprintf (from c)
-- usage:
--   ?qf("%/% is %%",3,8,3/8*100,"%")
function qf(fmt,...)
  local parts,args=split(fmt,"%"),pack(...)
  local str=deli(parts,1)
  for ix,pt in ipairs(parts) do
    str..=quote(args[ix])..pt
  end
  if args.n~=#parts then
    -- uh oh! mismatched arg count
    str..="(extraqf:"..(args.n-#parts)..")"
  end
  return str
end
function pqf(...) printh(qf(...)) end
:: main.lua
--[[pod_format="raw",created="2025-06-18 12:13:44",modified="2025-07-01 18:04:12",revision=1844]]
include "include.lua"
tileSize=16
halfTileSize=tileSize/2
screenWidth=480 --30 tiles
screenHeight=270 --16+ tiles
screenHeightTileAdjusted=256 
input=new_input(0)
mode=1
modes={}
game=nil

--include "test.lua"

--run_test()

function	restart()
	pq("----------------restart-----------------")
	mode=1
	game=new_game()
	game:init()
	modes[mode] = game
end
function _init()	
	pq("----------------start-----------------")
	god_ctors={malvex_god,
				flarim_god,
				dravak_god,
				skaza_god,
				velcrith_god,
				vireth_god,
				egru_god,
				myru_god,
				beloth_god,
				grask_god,
				velith_god,
				asul_god,
				noen_god,
				kyreth_god,
				caela_god,
				zuruth_god,
				meraxi_god,
				ilmeth_god,
				dreluun_god,
				soruun_god,
				yonvek_god,
				thimel_god,
				vollun_god,
				nethir_god,
				ezeleth_god
				}
		restart()
end

function _update()
	modes[mode]:update()
end
function _draw()

	modes[mode]:draw()
end


include "error_explorer.lua"
:: particle_system.lua
--[[pod_format="raw",created="2025-06-18 12:58:29",modified="2025-06-18 20:03:06",revision=397]]
function new_particle_system()
	return{
		sprites =game.sprites1,
		particles={},
		age=0,
		lifetime=60,
		spawn_rate=0.25; 
		particle_animation={},
		particle_flipx_r=false,
		particle_flipy_r=false,
		particle_lifetime=60,
		particle_halflife=1,
		position=new_point(0,0),
		particle_radial=false,
		particle_position_r=new_point(0,0),
		particle_speed=new_point(0,0),
		particle_speed_r=new_point(0,0),
		particle_acceleration=new_point(0,0),
		particle_acceleration_r=new_point(0,0),
		particle_update=nil, --leave nil for default behavior
		init=function(self)
			
		end,
		update=function(self)
			foreach(self.particles, function(particle)
    			particle:update()
 	 		end)
 	 		if( self.age>self.lifetime) then
 	 			if(#self.particles==0) then
 	 		 		self:die(game.particle_systems)
 	 		 	end
 	 		 	return
 	 		end
			if(self.spawn_rate>1) then
				for i=1,self.spawn_rate,1 do
					self:spawn()
				end
			else
				local inverse=1/self.spawn_rate
				if(self.age%inverse==0) then
					self:spawn()
				end
			end	
			self.age+=1
		end,
		draw=function(self)
			foreach(self.particles, function(particle)
    			particle:draw()
 	 		end)
		end,
		die=function(self,particle_system_container)
			del(particle_system_container,self)
		end,
		spawn=function(self)
			local particle=new_particle()
			particle.animation=self.particle_animation
			particle.lifetime=self.particle_lifetime
			particle.halflife=self.particle_halflife
			particle.position=self.position:randomize(self.particle_position_r)
			local speed=self.particle_speed:randomize(self.particle_speed_r)
			if(self.particle_radial) then
				speed=speed:square_to_circle()
			end
			particle.speed=	speed
			local acceleration=self.particle_acceleration:randomize(self.particle_acceleration_r)
			if(self.particle_radial) then
				acceleration=acceleration:square_to_circle()
			end	
			particle.acceleration=acceleration
		
			particle.particle_container=self.particles
			if(self.particle_flipx_r) then
				particle.flipx=rnd()>0.5
			end
			if(self.particle_flipy_r) then
				particle.flipy=rnd()>0.5
			end				
			particle.update=self.particle_update or particle.update
			add(self.particles,particle)
		end
	}
end
function new_particle()
	return{
		sprites =game.sprites1,
		particle_container,
		animation={},
		age=0,
		lifetime=60,
		halflife=1,
		position=new_point(0,0),
		speed=new_point(0,0),
		acceleration=new_point(0,0),
		flipx=false,
		flipy=false,
		init=function(self)
			
		end,
		update=function(self)
			self.position+=self.speed
			self.speed+=self.acceleration
			self.age+=1
		 		if(self.lifetime>=0 and self.age>self.lifetime) then
		 			self:die(self.particle_container)
		 		end
		 		if(rnd()>self.halflife) then
			 		self:die(self.particle_container)
		 		end
		end,
		draw=function(self)			
			spr(self.sprites[self.animation[self.age%#self.animation+1 ]].bmp,self.position.x,self.position.y,self.flipx,self.flipy)
		end,
		die=function(self,sprites)
			del(sprites,self)
		end
	}
end
	

:: point.lua
--[[pod_format="raw",created="2025-06-18 12:59:13",modified="2025-06-21 13:26:04",revision=560]]
function new_point(x,y)
	return sm({
		x=x,
		y=y,
		unitVector=function(self,b)
			return self.normalize(b-self)
		end,
		randomize=function(self,p)
			return new_point(self.x+random(p.x),	self.y+random(p.y))
		end,
		absPoint=function(p)
			return new_point(abs(p.x),abs(p.y))
		end,
		round=function(p,n)
			return new_point(flr(p.x/n+.5)*n,flr(p.y/n+.5)*n)
		end,
		clone=function(p)
			return new_point(p.x,p.y)
		end,
		length=function(p)
			return sqrt(p.x^2+p.y^2)
		end,
		square_to_circle=function (p)
	    local a = math.max( math.abs(p.x), math.abs(p.y)) -- max(|x|, |y|)
	    local mag = math.sqrt(p.x * p.x + p.y * p.y)
	
	    if mag == 0 then
	        return 0, 0 -- Origin stays at origin
	    end
	
	    local scale = a / mag
	    return new_point(p.x * scale, p.y * scale)
		end,
		__add=function(a,b)
			return new_point(a.x+b.x,a.y+b.y)
		end,
		__mul=function(a,b)
			return new_point(a.x*b,a.y*b)
		end,
		__sub=function(a,b)
			return new_point(a.x-b.x,a.y-b.y)
		end,
		equals=function(self,b)
			if(b == nil) then
				return false
			end
			return self.x==b.x and self.y==b.y
		end,
		__tostring=function()
			return "point"
		end,
		lerp=function(self, a, t)
		-- a and b are points, t is a number between 0 and 1
			local math=self + (a - self) * t
			--pq(self.x,a.x,t,math.x)
			return math
		end,
		box=function(self,left, top, right, bottom)
			self.x=mid(left,self.x,right)
			self.y=mid(top,self.y,bottom)
		end,
		normalize=function(p)
			local len = sqrt(p.x^2 + p.y^2)
			if len == 0 then return new_point(0, 0) end
			return new_point(p.x / len, p.y / len)
		end
	})
end

:: sfx.lua
--[[pod_format="raw",created="2025-06-18 12:57:03",modified="2025-06-18 20:03:06",revision=400]]
channels={
	ship=5,
	enemy=6
}

sfx_channels = {}
function play_sfx(sfx_id, channel,loop,restart)
	data = sfx_channels[channel]
	if data and (restart or false) and data.sfx_id == sfx_id then
		return
	end
	
		sfx(sfx_id, channel, loop)
		sfx_channels[channel] = {
			sfx_id = sfx_id,
			loop = loop,
			start_time = t()  -- use time() if preferred
		}

end

-- Stop SFX only if the given sfx is currently playing on the channel
function stop_sfx(sfx_id, channel)
	if channel then
		-- Stopping on a specific channel
		local data = sfx_channels[channel]
		if data and (sfx_id == nil or data.sfx_id == sfx_id) then
			sfx(-1, channel)
			sfx_channels[channel] = nil
		end
	elseif sfx_id == nil then
		-- No channel and no sfx_id: stop everything
		for ch, data in pairs(sfx_channels) do
			sfx(-1, ch)
			sfx_channels[ch] = nil
		end
		sfx(-1,channels.engine)

	end
end
:: shop.lua
--[[pod_format="raw",created="2025-06-27 23:43:15",modified="2025-07-01 20:50:59",revision=459]]

new_shop=function(stats)
	return {
		gods={},
		selected_god=0,
		stats=stats,
		god_cursor=nil,
		mode=0,
		selected_yes=false,
		init=function(self)
			self.mode=0
			self.god_cursor=new_shop_cursor(self)
			self.selected_god=1
			self.gods={}
			for i=1,3 do
				local god=nil
				while god==nil do
					local god_ctor=pick_random(god_ctors) 
					god=god_ctor(self.stats)
					for i=1,#self.stats.gods do
						if(god.name==self.stats.gods[i].name) then
							god=nil
							break
						end
					end
					if(god!=nil) then
						for i=1,#self.gods do
							if(god.name==self.gods[i].name) then
								god=nil
								break
							end
						end
					end
				end
				add(self.gods,god)
			end
		end,
		update=function(self)
			if(self.mode==0) then
				self.selected_yes=false
				if input:button_press(input_lookup.buttons.o) and self.gods[self.selected_god].cost<=self.stats.coins then 
					self.mode=1
				elseif(input:button_press(input_lookup.buttons.x)) then
					for i=1, #self.gods do
						if(self.gods[i].cost<=self.stats.coins) then
							self.mode=2
							return
						end
					end
					game:next_level()
				end
				self.god_cursor:update()
			elseif(self.mode==1) then
				if(input:button_press(input_lookup.buttons.o)) then
					if(self.selected_yes ) then
						game.stats:buy_god(self.gods[self.selected_god])
						game:next_level()
					else
						self.mode=0
					end
				elseif input:button_press(input_lookup.buttons.x) then 
					self.mode=0
				end
				if input:button_press(input_lookup.lpad.left) or input:button_press(input_lookup.lpad.right) then 
					self.selected_yes=not self.selected_yes
				end
			elseif(self.mode==2) then
				if input:button_press(input_lookup.buttons.o) then
					if(self.selected_yes) then
						game:next_level()
					else
						self.mode=0
					end
				elseif(input:button_press(input_lookup.buttons.x)) then
					self.mode=0
					--game:next_level()
				end
				if input:button_press(input_lookup.lpad.left) or input:button_press(input_lookup.lpad.right) then 
					self.selected_yes=not self.selected_yes
				end
			end
			
			
		end,
		draw=function(self)
			--draw the god icons
			local offset=new_point(170,209)	
			rectfill(offset.x,offset.y,offset.x+(52)*3+10,offset.y+52+5,19)
			for i=1,3 do
				local god=self.gods[i]
				if(god!=nil) then 
					god:draw(offset+new_point((i-1)*52+10,4))
				end
			end
			--draw the selected god
			self.gods[self.selected_god]:draw_modal()		
			self.god_cursor:draw()

			if(self.mode==1) then
				local god=self.gods[self.selected_god]
				rectfill(128,62,128+254,62+105,0)
				print("Pledge yourself to "..god.name,171,91,7)
				
				draw_button(new_point(191,128),"Yes",self.selected_yes)
				draw_button(new_point(275,128),"No",not self.selected_yes)
			end	
			if(self.mode==2) then
				local god=self.gods[self.selected_god]
				rectfill(128,62,128+254,62+105,0)
				print("Pass up the opportunity?" ,171,91,7)
				
				draw_button(new_point(191,128),"Yes",self.selected_yes)
				draw_button(new_point(275,128),"No",not self.selected_yes)
			end
		end
	}
end
:: shop_cursor.lua
--[[pod_format="raw",created="2025-06-29 03:54:41",modified="2025-07-01 18:04:12",revision=290]]
function new_shop_cursor(shop)
	return{
		god_count=3,
		shop=shop,
		init=function(self)			
		end,
		update=function(self)		
			if input:button_press(input_lookup.lpad.left) then 
				self.shop.selected_god =
					((self.shop.selected_god - 2) % self.god_count) + 1
			elseif input:button_press(input_lookup.lpad.right) then 
				self.shop.selected_god =
					(self.shop.selected_god % self.god_count) + 1
			end
		end,
		draw=function(self)
			
			local base_offset=new_point(170+10,209+4)	
			local offset=new_point((self.shop.selected_god-1)*(52),0)+base_offset
			rect(offset.x,offset.y,offset.x+42,offset.y+48,7)				

		end
	}
end
:: stats.lua
--[[pod_format="raw",created="2025-06-20 02:42:37",modified="2025-07-01 20:50:59",revision=1495]]
new_stats=function()
	return {
		points=0,
		messages={},
		chain_counter=1,
		color_values={},
		combo_values={},
		chain_values={},
		gods={},
		selected_god=0,
		moves_max=0,
		movetimer_max=0,
		
		match_vertical=false,
		match_horizontal=false,
		match_square=false,
		lives=1,
		coins=0,
		init=function(self)
			self.points=0
			selfchain_multiplier=1
			add(self.gods,new_base_god(self)) --add the initial stats in the base joker
		end,
		reset_trial=function(self)
			self.points=0
			self.chain_multiplier=1
			for _, god in ipairs(self.gods) do
				god:reset_trial()
			end
		end,
		match_length=function(self,matches)
			local n=0
			for _, god in ipairs(self.gods) do
				n=god:match_length(n,matches)
			end
			return n
		end,
		score_matches=function(self,matches)
			for _, god in ipairs(self.gods) do
				god:score_matches(matches)
			end
			self:update_stats()			
		end,		
		reset_chain=function(self)
			for _, god in ipairs(self.gods) do
				god:reset_chain()
			end
		end,
		update_stats=function(self)
			for _, god in ipairs(self.gods) do
				god:update()
			end
		end,
		draw=function(self)
			--colors
			for i=1,#self.color_values do
				spr(i,416,182+(i-1)*(tileSize+1))
				print(self.color_values[i],416+tileSize+2,182+((i-1)*tileSize+1)+6,7)
			end
			--combos
			print("combos",410,2,colors.green)
			for i=1,15 do
				print(pad_number((i+2),2).."=>"..self.combo_values[i] ,410,10+((i-1)*8),colors.green)
			end
			--chains
			print("chains",446,2,colors.periwinkle)
			for i=1,15 do
				print(pad_number((i),2).."=>x"..self.chain_values[i] ,442,10+((i-1)*8),colors.periwinkle)
			end			
			--gods
			for i=1,5 do
				for j=1,3 do
					local offset=new_point(2+(j-1)*46,(i-1)*52+2)
					rectfill(offset.x,offset.y,offset.x+42,offset.y+48,19)
					local god=self.gods[(i-1)*3+j+1]
					if(god!=nil) then 
						god:draw(offset)
					end
				end
			end
			if(self.selected_god!=0) then
				self.gods[self.selected_god]:draw_modal()
			end
		end,
		add_message=function(self,message,color)
			color = color or colors.light_gray
			add(self.messages,{text=message,color=color})
			if(#self.messages>10) then
				del(self.messages,self.messages[1])
			end
		end,
		buy_god=function(self,god)
				self.coins-=god.cost
				god:init()
				add(self.gods,god)
				self:update_stats()
		end
	}
end

:: test.lua
--[[pod_format="raw",created="2025-06-23 22:39:03",modified="2025-06-25 20:21:36",revision=384]]
		

function run_test()
	local gods={malvex_god,
		flarim_god,
		dravak_god,
		skarn_god,		
		green1_god,
		green2_god,
		green3_god}
	pq("----------------starting tests-----------------")
	for i=1,#gods do
		local ctor=gods[i]
		test_god(ctor)
	end
	pq("----------------ending tests-----------------")
	stop()
end
function test_god(god_ctor)
	local stats=new_stats()
	stats:init()
	local god=god_ctor(stats)
	add(stats.gods,god)
	stats:update_stats()
	stats:score_matches(test_get_matches({0,0,0,0,3}))
	stats:score_matches(test_get_matches({0,0,0,3,3}))
	stats:score_matches(test_get_matches({0,0,0,4,5}))
	stats:score_matches(test_get_matches({0,0,0,4,5}))
	stats:reset_chain()
	stats:score_matches(test_get_matches({0,0,0,0,3}))
	stats:score_matches(test_get_matches({0,0,0,3,3}))
	stats:score_matches(test_get_matches({0,0,0,4,5}))
	stats:score_matches(test_get_matches({0,0,0,4,5}))
	stats:reset_chain()
	stats:score_matches(test_get_matches({4,4,0,0,0}))
	stats:score_matches(test_get_matches({5,0,0,0,0}))
	stats:score_matches(test_get_matches({4,0,4,0,0}))
	stats:score_matches(test_get_matches({5,3,0,0,0}))
	stats:reset_chain()
	stats:score_matches(test_get_matches({4,4,0,0,0}))
	stats:score_matches(test_get_matches({5,0,0,0,0}))
	stats:score_matches(test_get_matches({4,0,4,0,0}))
	stats:score_matches(test_get_matches({3,5,0,0,0}))
	pq(god.name..":"..stats.points)
end

function test_get_matches(colors)
	ret={}
	for i=1,#colors do
		for j=1,colors[i] do
			local bead=new_bead(nil,new_point(1,j))
			bead.color=i
			add(ret,bead)
		end
	end
	return ret
end
:: ui.lua
--[[pod_format="raw",created="2025-06-29 23:44:00",modified="2025-07-01 18:04:12",revision=132]]
draw_button=function(top_left,text,selected,size,border_color,fill_color,text_color )
	selected=selected or false
	border_color=border_color or  25
	fill_color=fill_color or 6
	text_color=text_color or 24
	size=size or new_point(61,19)
	local bottom_right=top_left+size
	rectfill(top_left.x,top_left.y,bottom_right.x,bottom_right.y,fill_color)
	if(selected) then
		rect(top_left.x,top_left.y,bottom_right.x,bottom_right.y,border_color)
	end
	local text_x=size.x/2-2*#text
	local text_y=size.y/2-3
	print(text,top_left.x+text_x,top_left.y+text_y,text_color)	

end
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA2LTE4IDEzOjA5OjI5Iixtb2RpZmllZD0iMjAyNS0w
Ny0wMSAyMDo1MTo0MiIscnVudGltZT0xOCx3b3Jrc3BhY2VzPXt7bG9jYXRpb249ImdhbWUubHVh
Izg0Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJzdGF0cy5sdWEjNzYiLHdvcmtzcGFj
ZV9pbmRleD0xfSx7bG9jYXRpb249InNob3AubHVhIzE4Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xv
Y2F0aW9uPSJnb2RzL2JsdWVfZ29kcy5sdWEjMTAiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRp
b249ImdvZHMveWVsbG93X2dvZHMubHVhIzEwIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9u
PSJnb2RzL3JlZF9nb2RzLmx1YSMxMCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ29k
cy9ncmVlbl9nb2RzLmx1YSM3OSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ29kcy9w
dXJwbGVfZ29kcy5sdWEjMTAiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdvZHMvZ29k
Lmx1YSMxMCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0ibGV2ZWwubHVhIzkiLHdvcmtz
cGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHts
b2NhdGlvbj0ibWFwLzAubWFwIix3b3Jrc3BhY2VfaW5kZXg9M30se2xvY2F0aW9uPSJzZngvMC5z
ZngiLHdvcmtzcGFjZV9pbmRleD00fX1dXQ==
:: [eoc]
